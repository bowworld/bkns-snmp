<!DOCTYPE html>
<!-- VERSION: 1.0.1 - ADDED DUAL SCROLLBARS -->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNMP Viewer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text-main: #0f172a;
            --text-muted: #64748b;
            --border: #e2e8f0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0.5rem 1.5rem;
        }

        header {
            margin-bottom: 3rem;
            text-align: center;
        }

        h1 {
            font-weight: 600;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .settings-container {
            position: absolute;
            top: 2rem;
            right: 2rem;
        }

        .settings-btn {
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            border-radius: 8px;
        }

        .settings-btn:hover {
            background: #f1f5f9;
        }

        .dropdown-content.show {
            display: block;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.25rem;
            flex-shrink: 0;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 0.75rem 1rem;
            color: var(--text-muted);
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            border-radius: 0;
            transition: all 0.2s;
            font-family: inherit;
        }

        .tab-btn:hover {
            color: var(--text-main);
            background: #f1f5f9;
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .tab-pane {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
            /* Changed from auto to allow internal specialized scroll */
        }

        .tab-pane.active {
            display: flex;
        }

        /* Ensure specific tabs that need full scroll get it */
        #protocol-tab,
        #general-tab,
        #about-tab {
            overflow-y: auto;
            padding: 1rem;
        }

        #snmp-tab {
            padding: 0;
            flex-direction: column;
        }

        .snmp-header-area {
            flex: 0 0 auto;
            padding: 0.5rem 1rem;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            overflow-y: auto;
            max-height: 60vh;
            /* Prevents controls from taking up whole screen on small windows */
        }

        #results {
            flex: 1;
            padding: 0.5rem 1rem;
            /* overflow-y: auto is already on .tables-container */
        }

        /* General Settings Styles */
        .settings-card {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            max-width: 100%;
        }

        .settings-group {
            margin-bottom: 2rem;
        }

        .settings-group h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .controls-wrapper {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: flex-start;
            background: var(--card-bg);
            padding: 0.75rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            align-items: center;
        }

        .mib-panel {
            background: var(--card-bg);
            padding: 0.75rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .mib-panel h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .mib-list {
            max-height: 180px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem;
        }

        .mib-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.4rem 0.5rem;
            margin-bottom: 0.25rem;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid var(--border);
            transition: all 0.2s;
        }

        .mib-item:hover {
            border-color: var(--primary);
            background: #f1f5f9;
        }

        .status-badge {
            font-size: 0.6rem;
            padding: 1px 4px;
            border-radius: 4px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-badge.active {
            background: #dcfce7;
            color: #166534;
        }

        .status-badge.inactive {
            background: #f1f5f9;
            color: #64748b;
        }

        .mib-actions {
            margin-left: auto;
            display: flex;
            gap: 0.25rem;
        }

        .btn-mini {
            padding: 2px 4px;
            font-size: 0.65rem;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: white;
            cursor: pointer;
            color: #64748b;
        }

        .btn-mini:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: #eef2ff;
        }

        input[type="text"] {
            padding: 0.6rem 0.75rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.95rem;
            flex: 1;
            min-width: 150px;
            transition: border-color 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.6rem 1.25rem;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-success {
            background-color: #10b981 !important;
            color: white !important;
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .btn-secondary:hover {
            background-color: #eff6ff;
        }

        button:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary:hover {
            background-color: #eff6ff;
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            background-color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Tooltip Styles */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1e293b;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 400;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 2000;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        [data-tooltip]::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1e293b;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 2000;
            pointer-events: none;
        }

        [data-tooltip]:hover::after,
        [data-tooltip]:hover::before {
            opacity: 1;
            visibility: visible;
            bottom: calc(110% + 5px);
        }

        [data-tooltip]:hover::before {
            bottom: 110%;
        }

        .table-mapping-card {
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            background: #fafafa;
        }

        .mapping-columns-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .mapping-column-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            padding: 0.5rem;
        }

        .column-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0;
            font-size: 0.85rem;
        }

        .tables-container {
            display: grid;
            gap: 2rem;
        }

        .table-card {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            overflow: hidden;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-header h2 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-main);
        }

        .table-responsive {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        th,
        td {
            padding: 1rem 1.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: var(--text-muted);
            white-space: nowrap;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:hover td {
            background-color: #f1f5f9;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            display: none;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--primary);
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .active-input-highlight {
            border-color: var(--primary) !important;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2) !important;
            background-color: #f0f7ff !important;
        }

        .pick-btn {
            background: #ef4444;
            /* Red for Tags */
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-left: 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .pick-btn:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }

        .pick-field-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pick-field-btn:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .error-message {
            background-color: #fef2f2;
            color: #ef4444;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            text-align: center;
            display: none;
        }

        /* Dual Scrollbar Styles */
        .top-scroll-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            height: 12px;
            margin-bottom: 0;
            border-bottom: none;
            background: #f1f5f9;
            /* Light background for visibility */
        }

        .top-scroll-dummy {
            height: 1px;
        }

        .table-card {
            /* display: block is default, flex-shrink accounts for flex parent */
            flex-shrink: 0;
        }

        /* Fixed Layout Styles - Back to fixed for proper sticky controls */
        html,
        body {
            height: 100vh;
            overflow: hidden;
        }

        .container {
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
        }

        .top-section {
            flex: 0 0 auto;
            z-index: 20;
            position: relative;
            background-color: var(--bg);
            padding-bottom: 0.25rem;
        }

        /* Adjust margins to save space in fixed mode */
        header {
            margin-bottom: 1.5rem;
        }

        .controls-wrapper {
            margin-bottom: 0.5rem;
        }

        .tables-container {
            flex: 1 1 auto;
            overflow-y: auto;
            padding-right: 0.5rem;
            padding-bottom: 2rem;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 transparent;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .tables-container::-webkit-scrollbar {
            width: 8px;
        }

        .tables-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .tables-container::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
            border: 2px solid var(--bg);
        }

        .snmp-status-bar {
            padding: 0.6rem 1.5rem;
            background: #f8fafc;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #64748b;
            flex: 0 0 auto;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.02);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .snmp-status-bar .stat-group {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .snmp-status-bar .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .snmp-status-bar strong {
            color: var(--text-main);
            font-weight: 600;
        }

        .stat-badge {
            background: #eef2ff;
            padding: 0.1rem 0.6rem;
            border-radius: 6px;
            font-weight: 700;
            color: var(--primary);
            border: 1px solid #e0e7ff;
            font-family: monospace;
            font-size: 0.9rem;
        }

        /* MIB Tree Styles */
        .mib-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
        }

        .mib-modal-content {
            background-color: white;
            padding: 0;
            border-radius: 16px;
            width: 80%;
            max-width: 600px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .mib-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mib-modal-header h3 {
            margin: 0;
        }

        .mib-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .mib-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .mib-tree-item {
            cursor: pointer;
            padding: 0.25rem 0;
            display: flex;
            flex-direction: column;
        }

        .mib-tree-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .mib-tree-content:hover {
            background: #f1f5f9;
        }

        .mib-tree-content.selected {
            background: #eef2ff;
            color: var(--primary);
            font-weight: 600;
        }

        .mib-tree-children {
            margin-left: 1.5rem;
            display: none;
            border-left: 1px dashed #cbd5e1;
            padding-left: 0.5rem;
        }

        .mib-tree-children.expanded {
            display: block;
        }

        .toggle-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
            color: #64748b;
        }

        .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .oid-badge {
            font-size: 0.7rem;
            background: #f1f5f9;
            color: #64748b;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        .mib-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .mib-tree-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 0.5rem;
        }

        /* Root OID Combobox-like input */
        .oid-input-wrapper {
            position: relative;
            width: 100%;
            flex: none;
        }

        .oid-browse-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            padding: 6px 10px;
            background: #f1f5f9;
            border: 1px solid var(--border);
            color: #64748b;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .oid-browse-btn:hover {
            background: #e2e8f0;
            color: var(--text-main);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="top-section">
            <!-- Tab Navigation -->
            <nav class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('snmp-tab')" data-i18n="tab_snmp">SNMP
                    Settings</button>
                <button class="tab-btn" onclick="switchTab('protocol-tab')" data-i18n="tab_protocol">Line
                    Protocol</button>
                <button class="tab-btn" onclick="switchTab('telegraf-tab')" data-i18n="tab_telegraf">Telegraf</button>
                <button class="tab-btn" onclick="switchTab('general-tab')" data-i18n="tab_general">General
                    Settings</button>
                <button class="tab-btn" onclick="switchTab('about-tab')" data-i18n="tab_about">About</button>
            </nav>
        </div>

        <div id="mibModal" class="mib-modal">
            <div class="mib-modal-content">
                <div class="mib-modal-header">
                    <h3 data-i18n="mib_browser_title">MIB Browser</h3>
                    <button class="btn-secondary" onclick="closeMibBrowser()"
                        style="padding: 0.25rem 0.5rem;">✕</button>
                </div>
                <div style="padding: 1rem; border-bottom: 1px solid var(--border);">
                    <input type="text" id="mibSearchInput" placeholder="Search MIB objects..." style="width: 100%;">
                </div>
                <div id="mibTreeContainer" class="mib-modal-body">
                    <div style="text-align: center; padding: 2rem; color: #64748b;">Loading MIB tree...</div>
                </div>
                <div class="mib-modal-footer">
                    <button class="btn-secondary" onclick="closeMibBrowser()" data-i18n="cancel_btn">Cancel</button>
                    <button id="selectOidBtn" data-i18n="select_btn" disabled>Select OID</button>
                </div>
            </div>
        </div>

        <div class="tab-content">
            <!-- SNMP Settings Tab -->
            <div id="snmp-tab" class="tab-pane active">
                <div class="snmp-header-area">
                    <div class="controls-wrapper">
                        <div class="controls">
                            <textarea id="targetIp" placeholder="Target IP(s) (e.g., 192.168.2.1, 192.168.2.2)"
                                style="width: 100%; min-height: 40px; padding: 0.6rem; border-radius: 8px; border: 1px solid var(--border); font-size: 0.95rem; font-family: inherit; resize: vertical;">192.168.2.1</textarea>
                            <div class="oid-input-wrapper">
                                <input type="text" id="rootOid" placeholder="Root OID (Optional)" value="1.3.6.1"
                                    style="width: 100%; padding-right: 90px; box-sizing: border-box;">
                                <button class="oid-browse-btn" onclick="openMibBrowser()"
                                    data-i18n-tip="browse_mib_tip">Browse...</button>
                            </div>

                            <div style="display: flex; gap: 0.5rem; width: 100%; align-items: center;">
                                <select id="snmpVersion"
                                    style="padding: 0.6rem; border-radius: 8px; border: 1px solid var(--border); font-size: 0.95rem; background: white;">
                                    <option value="">Select SNMP Version...</option>
                                    <option value="1">SNMP v1</option>
                                    <option value="2c">SNMP v2c</option>
                                    <option value="3">SNMP v3</option>
                                </select>

                                <input type="text" id="community" placeholder="Community" value="public"
                                    style="flex: 2;">
                            </div>

                            <!-- SNMP v3 Fields (hidden by default) -->
                            <div id="v3Fields"
                                style="display: none; width: 100%; gap: 0.5rem; flex-direction: column; background: #f1f5f9; padding: 0.75rem; border-radius: 8px; margin-top: 0.25rem;">
                                <div style="display: flex; gap: 0.5rem;">
                                    <input type="text" id="v3User" placeholder="Username" value="user"
                                        style="width: 100%;">
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                    <select id="v3AuthProto"
                                        style="padding: 0.6rem; border-radius: 8px; border: 1px solid var(--border);">
                                        <option value="none">Auth: None</option>
                                        <option value="md5">MD5</option>
                                        <option value="sha">SHA</option>
                                    </select>
                                    <input type="password" id="v3AuthPwd" placeholder="Auth Password"
                                        style="padding: 0.6rem; border-radius: 8px; border: 1px solid var(--border);">
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                    <select id="v3PrivProto"
                                        style="padding: 0.6rem; border-radius: 8px; border: 1px solid var(--border);">
                                        <option value="none">Priv: None</option>
                                        <option value="des">DES</option>
                                        <option value="aes">AES128</option>
                                        <option value="aes256">AES256</option>
                                    </select>
                                    <input type="password" id="v3PrivPwd" placeholder="Priv Password"
                                        style="padding: 0.6rem; border-radius: 8px; border: 1px solid var(--border);">
                                </div>
                            </div>

                            <button id="scanBtn" style="width: 100%;" data-i18n-tip="scan_btn_tip">Scan Device</button>
                        </div>

                        <div class="mib-panel">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h3 data-i18n="mibs_header">MIB Files</h3>
                                <div style="display: flex; gap: 0.5rem;">
                                    <input type="file" id="mibUploadInput" style="display: none;" accept=".txt,.mib,.my"
                                        multiple>
                                    <button id="uploadMibBtn" class="btn-secondary" data-i18n="upload_btn"
                                        data-i18n-tip="upload_mib_tip"
                                        onclick="document.getElementById('mibUploadInput').click()">+ Upload</button>
                                </div>
                            </div>
                            <div id="mibList" class="mib-list">
                                <div style="padding: 0.5rem; color: var(--text-muted); text-align: center;">No MIBs
                                    found
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="errorBox" class="error-message"></div>

                    <div id="loading" class="loading">
                        <div class="spinner"></div>
                        <p data-i18n="scanning_text">Scanning device... This may take a few seconds.</p>
                        <button id="stopBtn" data-i18n="stop_btn" data-i18n-tip="stop_btn_tip"
                            style="background-color: #ef4444; margin-top: 1rem;">Stop
                            &
                            Reset
                            Interface</button>
                    </div>

                    <div id="toolbarContainer" style="margin-bottom: 1rem;">
                        <div
                            style="display: flex; align-items: flex-start; justify-content: space-between; gap: 1rem; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 250px; max-width: 400px;">
                                <div style="position: relative;">
                                    <span
                                        style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; color: #64748b; pointer-events: none; display: flex; align-items: center; justify-content: center; z-index: 10;">
                                        <svg width="20" height="20" fill="none" viewBox="0 0 24 24"
                                            stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                        </svg>
                                    </span>
                                    <input type="text" id="searchInput" placeholder="Search sections and columns..."
                                        style="width: 100%; padding-left: 40px; box-sizing: border-box;">
                                    <button id="clearSearchBtn" data-i18n-tip="clear_search_tip"
                                        style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; padding: 4px; cursor: pointer; color: #64748b;">
                                        <svg width="16" height="16" fill="none" viewBox="0 0 24 24"
                                            stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    </button>
                                </div>
                                <div id="searchInfo" style="margin-top: 0.25rem; font-size: 0.8125rem; color: #64748b;">
                                </div>
                            </div>
                            <div style="display: flex; gap: 1rem; align-items: center;">
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <button id="downloadTxtBtn" data-i18n="download_txt"
                                        data-i18n-tip="download_txt_tip"
                                        style="background-color: #64748b; padding: 0.5rem 1rem; font-size: 0.875rem;">Download
                                        TXT</button>
                                    <button id="downloadCsvBtn" data-i18n="download_csv"
                                        data-i18n-tip="download_csv_tip"
                                        style="padding: 0.5rem 1rem; font-size: 0.875rem;">Download
                                        CSV</button>
                                </div>
                                <div
                                    style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: white;">
                                    <input type="checkbox" id="hideNoDesc"
                                        style="width: 1.1rem; height: 1.1rem; cursor: pointer;">
                                    <label for="hideNoDesc" data-i18n="hide_no_desc"
                                        style="cursor: pointer; font-size: 0.875rem; font-weight: 500; white-space: nowrap;">Hide
                                        metrics without description</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="results" class="tables-container"></div>
                <div id="snmpStatusBar" class="snmp-status-bar" style="display: none;">
                    <div class="stat-group">
                        <div class="stat-item">
                            <strong data-i18n="total_oids">Total OIDs polled</strong>
                            <span id="totalOidsCount" class="stat-badge">0</span>
                        </div>
                        <div class="stat-item">
                            <strong data-i18n="displayed_oids">Displayed OIDs</strong>
                            <span id="displayedOidsCount" class="stat-badge">0</span>
                        </div>
                    </div>
                    <div id="snmpStatusRight" style="font-style: italic; opacity: 0.8;"></div>
                </div>
            </div>

            <!-- Telegraf Tab -->
            <div id="telegraf-tab" class="tab-pane">
                <div class="settings-card">
                    <div class="settings-group">
                        <h3 data-i18n="telegraf_management">Telegraf Management</h3>
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <label style="font-weight: 500;" data-i18n="config_path">Configuration File
                                    Path:</label>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <input type="text" id="telegraf-config-path"
                                        placeholder="/etc/telegraf/telegraf.conf" style="flex: 1; min-width: 200px;">
                                    <button id="save-telegraf-config-btn" class="btn-secondary" data-i18n="save_to_path"
                                        data-i18n-tip="save_path_tip">Save to Path</button>
                                    <button id="save-device-config-btn" class="btn-secondary"
                                        style="background: #3b82f6; color: white; border: none;"
                                        data-i18n="save_device_btn" data-i18n-tip="save_device_tip">Save as Device
                                        Config</button>
                                </div>
                                <p style="font-size: 0.8rem; color: var(--text-muted);" data-i18n="path_hint">Linux:
                                    /etc/telegraf/telegraf.d/snmp.conf | Windows: C:\Program
                                    Files\Telegraf\telegraf.conf</p>
                            </div>

                            <div
                                style="display: flex; gap: 1rem; align-items: center; background: #f8fafc; padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">
                                <div style="flex: 1;">
                                    <span style="font-weight: 600;" data-i18n="telegraf_status">Status:</span>
                                    <span id="telegraf-status-badge" class="status-badge inactive"
                                        style="margin-left: 0.5rem;">Stopped</span>
                                </div>
                                <div style="display: flex; gap: 0.5rem;">
                                    <button id="start-telegraf-btn" class="btn-success" data-i18n="start_telegraf"
                                        data-i18n-tip="start_telegraf_tip">Start
                                        Telegraf</button>
                                    <button id="stop-telegraf-btn" style="background: #ef4444;"
                                        data-i18n="stop_telegraf" data-i18n-tip="stop_telegraf_tip">Stop
                                        Telegraf</button>
                                    <button id="refresh-telegraf-status-btn" class="btn-secondary"
                                        data-i18n="refresh_status" data-i18n-tip="refresh_status_tip">Refresh
                                        Status</button>
                                </div>
                            </div>

                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <label style="font-weight: 500;" data-i18n="telegraf_logs">Logs (Output):</label>
                                    <button class="btn-mini" id="clear-telegraf-logs-btn" data-i18n="clear_logs"
                                        data-i18n-tip="clear_logs_tip">Clear
                                        Logs</button>
                                </div>
                                <div id="telegraf-logs-area"
                                    style="background: #1e293b; color: #f8fafc; font-family: monospace; font-size: 0.85rem; padding: 1rem; border-radius: 8px; height: 300px; overflow-y: auto; white-space: pre-wrap;">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Line Protocol Tab -->
            <div id="protocol-tab" class="tab-pane">
                <div class="settings-card">
                    <div class="settings-group"
                        style="position: sticky; top: 0; background: var(--card-bg); z-index: 10; padding-bottom: 1rem; margin-bottom: 2rem; border-bottom: 1px solid var(--border);">
                        <h3 data-i18n="lp_preview" style="margin-top: 0;">Line Protocol Preview</h3>
                        <div id="lpPreview"
                            style="padding: 1rem; background: #1e293b; color: #f8fafc; border-radius: 8px; font-family: monospace; white-space: pre-wrap; overflow-x: auto; border: 1px solid var(--border);">
                        </div>
                    </div>

                    <div class="settings-group">
                        <h3 data-i18n="lp_measurement">Measurement</h3>
                        <div style="display: flex; gap: 0.5rem; max-width: 500px;">
                            <input type="text" id="lpMeasurement" placeholder="e.g., snmp" value="snmp"
                                style="flex: 1; color: #3b82f6; font-weight: 500;">
                            <button id="saveLpSettingsBtn" data-i18n="save_btn"
                                data-i18n-tip="save_lp_tip">Save</button>
                            <button id="downloadLpTomlBtn" data-i18n="download_toml" class="btn-secondary"
                                data-i18n-tip="download_toml_tip">Download
                                TOML</button>
                        </div>
                    </div>

                    <div class="settings-group">
                        <h3 data-i18n="lp_tags">Tags</h3>
                        <div id="tagsContainer"
                            style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem;">
                            <!-- Tags will be rendered here -->
                        </div>
                        <button id="addTagBtn" class="btn-secondary" data-i18n-tip="add_tag_tip">+ Add Tag</button>
                    </div>
                    <div class="settings-group">
                        <h3 data-i18n="lp_fields">Fields (Scalars)</h3>
                        <div id="fieldsContainer"
                            style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem;">
                            <!-- Fields will be rendered here -->
                        </div>
                        <button id="addFieldBtn" class="btn-secondary" data-i18n-tip="add_field_tip">+ Add Scalar
                            Field</button>
                    </div>

                    <div class="settings-group">
                        <h3 data-i18n="lp_table_mappings">Table Mappings</h3>
                        <div id="tableMappingsContainer"
                            style="display: flex; flex-direction: column; gap: 1.5rem; margin-bottom: 1rem;">
                            <!-- Table mappings will be rendered here -->
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;"
                            data-i18n="std_practice_desc">
                            Mapping entire tables: pick a column as a Tag to identify rows, and other columns as Fields.
                        </p>
                    </div>

                    <div class="settings-group">
                        <h3 data-i18n="lp_timestamp">Timestamp</h3>
                        <div style="display: flex;">
                            <input type="text" id="lpTimestamp" value="1623456789000000000" disabled
                                style="flex: 1; color: #eab308; font-weight: 500; background-color: #f8fafc; cursor: not-allowed; border: 1px solid var(--border);">
                        </div>
                    </div>

                    <div class="settings-group">
                        <h3 data-i18n="lp_agent_config">[agent] Configuration</h3>
                        <textarea id="lpAgentConfig"
                            style="width: 100%; height: 150px; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; font-family: monospace; font-size: 0.9rem; resize: vertical;">[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = ""
  hostname = ""
  omit_hostname = false</textarea>
                    </div>

                    <div class="settings-group">
                        <h3 data-i18n="lp_output_config">[[outputs.influxdb_v2]] Configuration</h3>
                        <textarea id="lpOutputConfig"
                            style="width: 100%; height: 120px; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; font-family: monospace; font-size: 0.9rem; resize: vertical;">[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]
  token = "my-super-secret-auth-token"
  organization = "bkns"
  bucket = "snmp-data"</textarea>
                    </div>
                </div>
            </div>

            <!-- General Settings Tab -->
            <div id="general-tab" class="tab-pane">
                <div class="settings-card">
                    <div class="settings-group">
                        <h3 data-i18n="language_label">Language</h3>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <label class="lang-option"
                                style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="radio" name="language" value="en" checked onclick="changeLanguage('en')">
                                <span style="font-weight: 500;">English</span>
                            </label>
                            <label class="lang-option"
                                style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="radio" name="language" value="ru" onclick="changeLanguage('ru')">
                                <span style="font-weight: 500;">Русский</span>
                            </label>
                            <label class="lang-option"
                                style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                                <input type="radio" name="language" value="kk" onclick="changeLanguage('kk')">
                                <span style="font-weight: 500;">Қазақша</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- About Tab -->
            <div id="about-tab" class="tab-pane">
                <div class="settings-card" style="max-width: 800px;">
                    <h2 data-i18n="tab_about">About SNMP Viewer</h2>
                    <div style="line-height: 1.6; color: var(--text-main);">
                        <p><strong>SNMP Viewer</strong> is a professional tool designed to explore and visualize
                            Data Center engineering equipment parameters via SNMP protocol.</p>

                        <h4 style="margin-top: 2rem;">Instructions</h4>
                        <ul style="padding-left: 1.5rem;">
                            <li>Enter the target IP address of your equipment.</li>
                            <li>Select the appropriate SNMP version (v1, v2c, or v3).</li>
                            <li>Provide necessary credentials (Community string or v3 Auth/Priv details).</li>
                            <li>Upload custom MIB files to translate numeric OIDs into human-readable labels.</li>
                            <li>Click "Scan Device" to retrieve and visualize system metrics.</li>
                        </ul>

                        <h4 style="margin-top: 2rem;">Authorship</h4>
                        <p>Developed for efficient infrastructure monitoring and planning.</p>
                    </div>
                </div>
            </div>
        </div>

        <script>
            const scanBtn = document.getElementById('scanBtn');
            const targetIp = document.getElementById('targetIp');
            const rootOid = document.getElementById('rootOid');
            const community = document.getElementById('community');
            const snmpVersion = document.getElementById('snmpVersion');
            const v3Fields = document.getElementById('v3Fields');
            const resultsDiv = document.getElementById('results');
            const loadingDiv = document.getElementById('loading');
            const errorBox = document.getElementById('errorBox');
            const mibListDiv = document.getElementById('mibList');
            const mibUploadInput = document.getElementById('mibUploadInput');

            const downloadTxtBtn = document.getElementById('downloadTxtBtn');
            const downloadCsvBtn = document.getElementById('downloadCsvBtn');
            const stopBtn = document.getElementById('stopBtn');
            const toolbarContainer = document.getElementById('toolbarContainer');
            const searchInput = document.getElementById('searchInput');
            const clearSearchBtn = document.getElementById('clearSearchBtn');
            const searchInfo = document.getElementById('searchInfo');
            const hideNoDescCheckbox = document.getElementById('hideNoDesc');
            const settingsDropdown = document.getElementById('settingsDropdown');
            const lpMeasurement = document.getElementById('lpMeasurement');
            const lpPreview = document.getElementById('lpPreview');
            const saveLpSettingsBtn = document.getElementById('saveLpSettingsBtn');
            const tagsContainer = document.getElementById('tagsContainer');
            const addTagBtn = document.getElementById('addTagBtn');
            const fieldsContainer = document.getElementById('fieldsContainer');
            const addFieldBtn = document.getElementById('addFieldBtn');
            const downloadLpTomlBtn = document.getElementById('downloadLpTomlBtn');
            const lpAgentConfig = document.getElementById('lpAgentConfig');
            const lpOutputConfig = document.getElementById('lpOutputConfig');
            const snmpStatusBar = document.getElementById('snmpStatusBar');
            const totalOidsCount = document.getElementById('totalOidsCount');
            const displayedOidsCount = document.getElementById('displayedOidsCount');
            const telegrafTab = document.getElementById('telegraf-tab');
            const telegrafConfigPath = document.getElementById('telegraf-config-path');
            const saveTelegrafConfigBtn = document.getElementById('save-telegraf-config-btn');
            const telegrafStatusBadge = document.getElementById('telegraf-status-badge');
            const startTelegrafBtn = document.getElementById('start-telegraf-btn');
            const stopTelegrafBtn = document.getElementById('stop-telegraf-btn');
            const refreshTelegrafStatusBtn = document.getElementById('refresh-telegraf-status-btn');
            const telegrafLogsArea = document.getElementById('telegraf-logs-area');
            const clearTelegrafLogsBtn = document.getElementById('clear-telegraf-logs-btn');
            const saveDeviceConfigBtn = document.getElementById('save-device-config-btn');

            let lastScanData = null;
            let searchQuery = '';
            let abortController = null;
            let activeInputForPicking = null;
            const translations = {
                en: {
                    title: "SNMP Viewer",
                    header_h1: "SNMP Data Viewer",
                    header_p: "Explore your network equipment data visually",
                    settings_btn: "Settings",
                    language_label: "Language",
                    hide_no_desc: "Hide metrics without description",
                    target_ip_placeholder: "Target IP(s) (one per line or comma separated)",
                    root_oid_placeholder: "Root OID (Default: 1.3.6)",
                    community_placeholder: "Community",
                    snmp_v_select: "Select SNMP Version...",
                    scan_btn: "Scan Device",
                    scanning_btn: "Scanning...",
                    mibs_header: "MIB Files",
                    upload_btn: "+ Upload",
                    delete_btn: "Delete",
                    no_mibs: "No MIBs found",
                    scanning_text: "Scanning device... This may take a few seconds.",
                    stop_btn: "Stop & Reset Interface",
                    search_placeholder: "Search sections and columns...",
                    download_txt: "Download TXT",
                    download_csv: "Download CSV",
                    general_info: "General Information",
                    data_group: "Data Group",
                    found_sections: "Found {visible} of {total} sections",
                    no_data: "No data found.",
                    no_results: "No sections match your search.",
                    name_oid_col: "Name / OID",
                    value_col: "Value",
                    desc_col: "Description",
                    index_col: "Index",
                    no_desc_label: "no description",
                    v3_user_placeholder: "Username",
                    v3_auth_pwd_placeholder: "Auth Password",
                    v3_priv_pwd_placeholder: "Priv Password",
                    v3_auth_none: "Auth: None",
                    v3_priv_none: "Priv: None",
                    error_ip: "Please enter a target IP address.",
                    error_version: "Please select an SNMP version protocol.",
                    confirm_delete: "Are you sure you want to delete {count} MIB file(s)?",
                    delete_failed: "Delete failed: ",
                    upload_failed: "Upload failed: ",
                    tab_snmp: "SNMP Settings",
                    tab_protocol: "Line Protocol",
                    tab_general: "General Settings",
                    tab_about: "About",
                    lp_measurement: "Measurement Name",
                    lp_preview: "Line Protocol Preview",
                    save_btn: "Save",
                    lp_scale: "Scale",
                    lp_tags: "Tags",
                    lp_fields: "Fields (Scalars)",
                    lp_table_mappings: "Table Mappings",
                    map_table_btn: "Map Whole Table",
                    select_tags: "Select Tags (Identifiers)",
                    standard_practice: "Standard Practice:",
                    std_practice_desc: "Use name/descr columns as Tags, and status/numeric columns as Fields.",
                    download_toml: "Download TOML",
                    tab_telegraf: "Telegraf",
                    telegraf_management: "Telegraf Management",
                    config_path: "Configuration File Path:",
                    save_to_path: "Save to Path",
                    path_hint: "Linux: /etc/telegraf/telegraf.d/snmp.conf | Windows: C:\\Program Files\\Telegraf\\telegraf.conf",
                    telegraf_status: "Status:",
                    start_telegraf: "Start Telegraf",
                    stop_telegraf: "Stop Telegraf",
                    refresh_status: "Refresh Status",
                    telegraf_logs: "Logs (Output):",
                    clear_logs: "Clear Logs",
                    telegraf_started: "Telegraf started successfully",
                    telegraf_stopped: "Telegraf stopped",
                    telegraf_save_success: "Config saved to path successfully",
                    status_stopped: "Stopped",
                    status_running: "Running",
                    lp_agent_config: "[agent] Configuration",
                    lp_output_config: "[[outputs.influxdb_v2]] Configuration",
                    total_oids: "Total OIDs polled",
                    displayed_oids: "Displayed OIDs",
                    save_device_btn: "Save as Device Config (telegraf.d)",
                    no_sn_error: "Please add 'device_sn' tag to identify the device file.",
                    scan_btn_tip: "Start SNMP scan of the target device",
                    stop_btn_tip: "Immediately stop all processes and reset the UI",
                    upload_mib_tip: "Upload MIB files for OID translation",
                    browse_mib_tip: "Browse the OID tree of loaded MIBs",
                    download_txt_tip: "Export raw results as a text report",
                    download_csv_tip: "Export results as a structured CSV file",
                    save_lp_tip: "Save current measurement, tags, and fields settings",
                    download_toml_tip: "Download the generated Telegraf configuration",
                    save_path_tip: "Save the full configuration to the specified system path",
                    save_device_tip: "Save device-specific configuration to telegraf.d directory",
                    start_telegraf_tip: "Start the Telegraf service with current configuration",
                    stop_telegraf_tip: "Stop the running Telegraf service",
                    refresh_status_tip: "Check the current status and logs of Telegraf",
                    clear_logs_tip: "Clear the log output window",
                    add_tag_tip: "Add a new static tag to the Line Protocol",
                    add_field_tip: "Add a new scalar field mapping",
                    clear_search_tip: "Clear the current search filter",
                    map_table_tip: "Configure entire SNMP table mapping",
                    mib_browser_title: "MIB Browser",
                    cancel_btn: "Cancel",
                    select_btn: "Select",
                    btn_load: "Load",
                    btn_unload: "Unload",
                    btn_delete: "Delete",
                    status_active: "Active",
                    status_file: "File",
                    confirm_delete_single: "Are you sure you want to delete this MIB file?"
                },
                ru: {
                    title: "SNMP Просмотрщик",
                    header_h1: "Просмотр данных SNMP",
                    header_p: "Визуальное исследование данных сетевого оборудования",
                    settings_btn: "Настройки",
                    language_label: "Язык",
                    hide_no_desc: "Скрыть метрики без описания",
                    target_ip_placeholder: "Целевые IP (один в строке или через запятую)",
                    root_oid_placeholder: "Корневой OID (По умолчанию: 1.3.6)",
                    community_placeholder: "Сообщество (Community)",
                    snmp_v_select: "Выберите версию SNMP...",
                    scan_btn: "Сканировать устройство",
                    scanning_btn: "Сканирование...",
                    mibs_header: "MIB файлы",
                    upload_btn: "+ Загрузить",
                    delete_btn: "Удалить",
                    no_mibs: "MIB файлы не найдены",
                    scanning_text: "Сканирование устройства... Это может занять несколько секунд.",
                    stop_btn: "Остановить и сбросить интерфейс",
                    search_placeholder: "Поиск по разделам и колонкам...",
                    download_txt: "Скачать TXT",
                    download_csv: "Скачать CSV",
                    general_info: "Общая информация",
                    data_group: "Группа данных",
                    found_sections: "Найдено {visible} из {total} разделов",
                    no_data: "Данные не найдены.",
                    no_results: "Нет разделов, соответствующих вашему поиску.",
                    name_oid_col: "Имя / OID",
                    value_col: "Значение",
                    desc_col: "Описание",
                    index_col: "Индекс",
                    no_desc_label: "нет описания",
                    v3_user_placeholder: "Имя пользователя",
                    v3_auth_pwd_placeholder: "Пароль аутентификации",
                    v3_priv_pwd_placeholder: "Пароль приватности",
                    v3_auth_none: "Аунт: Нет",
                    v3_priv_none: "Прив: Нет",
                    error_ip: "Пожалуйста, введите целевой IP-адрес.",
                    error_version: "Пожалуйста, выберите протокол версии SNMP.",
                    confirm_delete: "Вы уверены, что хотите удалить {count} MIB файл(ов)?",
                    delete_failed: "Ошибка удаления: ",
                    upload_failed: "Ошибка загрузки: ",
                    tab_snmp: "SNMP Настройки",
                    tab_protocol: "Line Protocol",
                    tab_general: "Общие настройки",
                    tab_about: "О проекте",
                    lp_measurement: "Имя измерения (Measurement)",
                    lp_preview: "Предпросмотр Line Protocol",
                    save_btn: "Сохранить",
                    lp_scale: "Множитель",
                    lp_tags: "Теги (Tags)",
                    lp_fields: "Поля (Скалярные)",
                    lp_table_mappings: "Маппинг таблиц",
                    map_table_btn: "Маппить таблицу целиком",
                    select_tags: "Выберите Теги (Идентификаторы)",
                    standard_practice: "Стандартная практика:",
                    std_practice_desc: "Используйте колонки с именами/описанием как Теги, а числовые данные — как Поля.",
                    download_toml: "Скачать TOML",
                    tab_telegraf: "Telegraf",
                    telegraf_management: "Управление Telegraf",
                    config_path: "Путь к файлу конфигурации:",
                    save_to_path: "Сохранить по пути",
                    path_hint: "Linux: /etc/telegraf/telegraf.d/snmp.conf | Windows: C:\\Program Files\\Telegraf\\telegraf.conf",
                    telegraf_status: "Статус:",
                    start_telegraf: "Запустить Telegraf",
                    stop_telegraf: "Остановить Telegraf",
                    refresh_status: "Обновить статус",
                    telegraf_logs: "Логи (Вывод):",
                    clear_logs: "Очистить логи",
                    telegraf_started: "Telegraf запущен успешно",
                    telegraf_stopped: "Telegraf остановлен",
                    telegraf_save_success: "Конфигурация успешно сохранена по указанному пути",
                    status_stopped: "Остановлен",
                    status_running: "Запущен",
                    lp_agent_config: "Конфигурация [agent]",
                    lp_output_config: "Конфигурация [[outputs.influxdb_v2]]",
                    total_oids: "Всего OID опрошено",
                    displayed_oids: "Отображаемых OID",
                    save_device_btn: "Сохранить как конфиг устройства (telegraf.d)",
                    no_sn_error: "Пожалуйста, добавьте тег 'device_sn' для идентификации файла устройства.",
                    scan_btn_tip: "Начать SNMP сканирование целевого устройства",
                    stop_btn_tip: "Немедленно остановить все процессы и сбросить интерфейс",
                    upload_mib_tip: "Загрузить MIB файлы для перевода OID",
                    browse_mib_tip: "Просмотр дерева OID загруженных MIB файлов",
                    download_txt_tip: "Экспортировать результаты в текстовый отчет",
                    download_csv_tip: "Экспортировать результаты в таблицу CSV",
                    save_lp_tip: "Сохранить настройки измерения, тегов и полей",
                    download_toml_tip: "Скачать сгенерированный конфиг Telegraf",
                    save_path_tip: "Сохранить полный конфиг по указанному системному пути",
                    save_device_tip: "Сохранить конфиг устройства в папку telegraf.d",
                    start_telegraf_tip: "Запустить службу Telegraf с текущим конфигом",
                    stop_telegraf_tip: "Остановить работающую службу Telegraf",
                    refresh_status_tip: "Обновить статус и логи Telegraf",
                    clear_logs_tip: "Очистить окно вывода логов",
                    add_tag_tip: "Добавить новый статический тег в Line Protocol",
                    add_field_tip: "Добавить новый маппинг скалярного поля",
                    clear_search_tip: "Очистить фильтр поиска",
                    map_table_tip: "Настроить маппинг всей SNMP таблицы",
                    mib_browser_title: "MIB браузер",
                    cancel_btn: "Отмена",
                    select_btn: "Выбрать",
                    btn_load: "Загрузить",
                    btn_unload: "Выгрузить",
                    btn_delete: "Удалить",
                    status_active: "Активен",
                    status_file: "Файл",
                    confirm_delete_single: "Вы действительно хотите удалить этот MIB файл?"
                },
                kk: {
                    title: "SNMP Көруші",
                    header_h1: "SNMP деректерін көру",
                    header_p: "Желілік жабдық деректерін визуалды түрде зерттеу",
                    settings_btn: "Параметрлер",
                    language_label: "Тіл",
                    hide_no_desc: "Сипаттамасы жоқ метрикаларды жасыру",
                    target_ip_placeholder: "Нысаналы IP-лер (әр жолда бір немесе үтірмен)",
                    root_oid_placeholder: "Түбірлік OID (Әдепкі: 1.3.6)",
                    community_placeholder: "Қауымдастық (Community)",
                    snmp_v_select: "SNMP нұсқасын таңдаңыз...",
                    scan_btn: "Құрылғыны сканерлеу",
                    scanning_btn: "Сканерлеу...",
                    mibs_header: "MIB файлдары",
                    upload_btn: "+ Жүктеу",
                    delete_btn: "Жою",
                    no_mibs: "MIB файлдары табылмады",
                    scanning_text: "Құрылғыны сканерлеу... Бұл бірнеше секунд алуы мүмкін.",
                    stop_btn: "Тоқтату және интерфейсті қайта орнату",
                    search_placeholder: "Бөлімдер мен бағандар бойынша іздеу...",
                    download_txt: "TXT жүктеу",
                    download_csv: "CSV жүктеу",
                    general_info: "Жалпы ақпарат",
                    data_group: "Деректер тобы",
                    found_sections: "{total} бөлімнің {visible} табылды",
                    no_data: "Деректер табылмады.",
                    no_results: "Іздеуіңізге сәйкес келетін бөлімдер жоқ.",
                    name_oid_col: "Аты / OID",
                    value_col: "Мән",
                    desc_col: "Сипаттама",
                    index_col: "Индекс",
                    no_desc_label: "сипаттама жоқ",
                    v3_user_placeholder: "Пайдаланушы аты",
                    v3_auth_pwd_placeholder: "Аутентификация құпия сөзі",
                    v3_priv_pwd_placeholder: "Құпиялылық құпия сөзі",
                    v3_auth_none: "Аунт: Жоқ",
                    v3_priv_none: "Прив: Жоқ",
                    error_ip: "Мақсатты IP мекенжайын енгізіңіз.",
                    error_version: "SNMP нұсқасының протоколын таңдаңыз.",
                    confirm_delete: "{count} MIB файлын жоюыңызға сенімдісіз бе?",
                    delete_failed: "Жою сәтсіз аяқталды: ",
                    upload_failed: "Жүктеу сәтсіз аяқталды: ",
                    tab_snmp: "SNMP Параметрлері",
                    tab_protocol: "Line Protocol",
                    tab_general: "Жалпы параметрлер",
                    tab_about: "Жоба туралы",
                    lp_measurement: "Measurement атауы",
                    lp_preview: "Line Protocol алдын ала қарау",
                    save_btn: "Сақтау",
                    lp_scale: "Множитель",
                    lp_tags: "Тегтер (Tags)",
                    lp_fields: "Өрістер (Скалярлы)",
                    lp_table_mappings: "Кестелерді сәйкестендіру",
                    map_table_btn: "Кестені толығымен сәйкестендіру",
                    select_tags: "Тегтерді таңдаңыз (Идентификаторлар)",
                    standard_practice: "Стандартты практика:",
                    std_practice_desc: "Аты/сипаттамасы бар бағандарды Тег ретінде, ал сандық деректерді Өріс ретінде пайдаланыңыз.",
                    download_toml: "TOML жүктеу",
                    tab_telegraf: "Telegraf",
                    telegraf_management: "Telegraf басқару",
                    config_path: "Конфигурация файлының жолы:",
                    save_to_path: "Жолға сақтау",
                    path_hint: "Linux: /etc/telegraf/telegraf.d/snmp.conf | Windows: C:\\Program Files\\Telegraf\\telegraf.conf",
                    telegraf_status: "Күйі:",
                    start_telegraf: "Telegraf іске қосу",
                    stop_telegraf: "Telegraf тоқтату",
                    refresh_status: "Күйді жаңарту",
                    telegraf_logs: "Логтар (Шығыс):",
                    clear_logs: "Логтарды тазалау",
                    telegraf_started: "Telegraf сәтті іске қосылды",
                    telegraf_stopped: "Telegraf тоқтатылды",
                    telegraf_save_success: "Конфигурация көрсетілген жолға сәтті сақталды",
                    status_stopped: "Тоқтатылды",
                    status_running: "Іске қосылды",
                    lp_agent_config: "[agent] конфигурациясы",
                    lp_output_config: "[[outputs.influxdb_v2]] конфигурациясы",
                    total_oids: "Барлығы OID сұралды",
                    displayed_oids: "Көрсетілген OID",
                    save_device_btn: "Құрылғы конфигі ретінді сақтау (telegraf.d)",
                    no_sn_error: "Құрылғы файлын анықтау үшін 'device_sn' тегін қосыңыз.",
                    scan_btn_tip: "Нысаналы құрылғыны SNMP сканерлеуді бастау",
                    stop_btn_tip: "Барлық процестерді дереу тоқтату және интерфейсті қайтару",
                    upload_mib_tip: "OID аудару үшін MIB файлдарын жүктеу",
                    browse_mib_tip: "Жүктелген MIB файлдарының OID ағашын көру",
                    download_txt_tip: "Нәтижелерді мәтіндік есеп ретінде экспорттау",
                    download_csv_tip: "Нәтижелерді CSV кестесі ретінде экспорттау",
                    save_lp_tip: "Өлшем, тег және өріс параметрлерін сақтау",
                    download_toml_tip: "Жасалған Telegraf конфигурациясын жүктеу",
                    save_path_tip: "Толық конфигурацияны көрсетілген жүйелік жолға сақтау",
                    save_device_tip: "Құрылғы конфигурациясын telegraf.d қалтасына сақтау",
                    start_telegraf_tip: "Telegraf қызметін ағымдағы конфигурациямен іске қосу",
                    stop_telegraf_tip: "Жұмыс істеп тұрған Telegraf қызметін тоқтату",
                    refresh_status_tip: "Telegraf күйін және логтарын тексеру",
                    clear_logs_tip: "Логтарды шығару терезесін тазалау",
                    add_tag_tip: "Line Protocol-ға жаңа статикалық тег қосу",
                    add_field_tip: "Жаңа скалярлы өрісті сәйкестендіруді қосу",
                    clear_search_tip: "Іздеу сүзгісін тазалау",
                    map_table_tip: "Барлық SNMP кестесін сәйкестендіруді конфигурациялау",
                    mib_browser_title: "MIB браузері",
                    cancel_btn: "Бас тарту",
                    select_btn: "Таңдау",
                    btn_load: "Жүктеу",
                    btn_unload: "Шығару",
                    btn_delete: "Жою",
                    status_active: "Белсенді",
                    status_file: "Файл",
                    confirm_delete_single: "Бұл MIB файлын жоюыңызға сенімдісіз бе?"
                }
            };

            let currentLang = localStorage.getItem('selectedLanguage') || 'en';

            function applyTranslations(lang) {
                currentLang = lang;
                localStorage.setItem('selectedLanguage', lang);
                const t = translations[lang];

                // Update title
                document.title = t.title;

                // Update elements with data-i18n attribute
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) {
                        el.textContent = t[key];
                    }
                });

                // Update elements with data-i18n-tip attribute
                document.querySelectorAll('[data-i18n-tip]').forEach(el => {
                    const key = el.getAttribute('data-i18n-tip');
                    if (t[key]) {
                        el.setAttribute('data-tooltip', t[key]);
                    }
                });

                // Update placeholders and options
                document.getElementById('targetIp').placeholder = t.target_ip_placeholder;
                document.getElementById('rootOid').placeholder = t.root_oid_placeholder;
                document.getElementById('community').placeholder = t.community_placeholder;
                document.getElementById('searchInput').placeholder = t.search_placeholder;
                document.getElementById('v3User').placeholder = t.v3_user_placeholder;
                document.getElementById('v3AuthPwd').placeholder = t.v3_auth_pwd_placeholder;
                document.getElementById('v3PrivPwd').placeholder = t.v3_priv_pwd_placeholder;

                // Default config path based on OS (heuristic)
                const isWindows = navigator.platform.indexOf('Win') !== -1;
                if (telegrafConfigPath && !telegrafConfigPath.value) {
                    telegrafConfigPath.value = isWindows ? 'C:\\Program Files\\Telegraf\\telegraf.conf' : '/etc/telegraf/telegraf.conf';
                }

                // Update text for buttons and labels that might change
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) el.textContent = t[key];
                });

                const snmpVSelect = document.getElementById('snmpVersion');
                snmpVSelect.options[0].textContent = t.snmp_v_select;

                const v3AuthProto = document.getElementById('v3AuthProto');
                v3AuthProto.options[0].textContent = t.v3_auth_none;

                const v3PrivProto = document.getElementById('v3PrivProto');
                v3PrivProto.options[0].textContent = t.v3_priv_none;

                // Update scan button text if not scanning
                if (!scanBtn.disabled) {
                    scanBtn.textContent = t.scan_btn;
                } else {
                    scanBtn.textContent = t.scanning_btn;
                }

                // Sync radio button
                document.querySelectorAll('input[name="language"]').forEach(radio => {
                    radio.checked = radio.value === lang;
                });

                // Re-render components that might need translation (like search results info)
                if (lastScanData) {
                    renderTables(lastScanData);
                } else {
                    fetchMibs(); // To translate "No MIBs found" if empty
                }
            }

            function changeLanguage(lang) {
                applyTranslations(lang);
            }

            function switchTab(tabId) {
                // Update buttons
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('onclick').includes(tabId)) {
                        btn.classList.add('active');
                    }
                });

                // Update panes
                document.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('active');
                });
                document.getElementById(tabId).classList.add('active');

                localStorage.setItem('activeTab', tabId);
            }

            // Initialize language and tab
            applyTranslations(currentLang);
            const savedTab = localStorage.getItem('activeTab') || 'snmp-tab';
            switchTab(savedTab);

            hideNoDescCheckbox.addEventListener('change', () => {
                if (lastScanData) {
                    renderTables(lastScanData);
                }
            });

            // Search functionality
            searchInput.addEventListener('input', (e) => {
                searchQuery = e.target.value.trim().toLowerCase();
                clearSearchBtn.style.display = searchQuery ? 'block' : 'none';
                if (lastScanData) {
                    renderTables(lastScanData);
                }
            });

            clearSearchBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchQuery = '';
                clearSearchBtn.style.display = 'none';
                searchInfo.textContent = '';
                if (lastScanData) {
                    renderTables(lastScanData);
                }
            });

            // Stop button functionality
            stopBtn.addEventListener('click', () => {
                if (abortController) {
                    abortController.abort();
                }
                location.reload(); // Quick and easy way to "reset interface" as requested
            });

            // Toggle v3 fields visibility
            snmpVersion.addEventListener('change', () => {
                if (snmpVersion.value === '3') {
                    v3Fields.style.display = 'flex';
                    community.style.display = 'none';
                } else {
                    v3Fields.style.display = 'none';
                    community.style.display = 'block';
                }
            });

            function updateLineProtocolPreview() {
                const measurement = lpMeasurement.value.trim() || 'snmp';

                // Get tags
                const tagPairs = [];
                document.querySelectorAll('.tag-row').forEach(row => {
                    const key = row.querySelector('.tag-key').value.trim();
                    const val = row.querySelector('.tag-val').value.trim();
                    if (key) {
                        tagPairs.push(`${key}=${val}`);
                    }
                });

                const tagsStr = tagPairs.length > 0 ? ',' + tagPairs.join(',') : '';

                // Get fields
                const fieldPairs = [];
                document.querySelectorAll('.field-row').forEach(row => {
                    const key = row.querySelector('.field-key').value.trim();
                    const oidOrVal = row.querySelector('.field-val').value.trim();
                    if (key) {
                        let displayVal = '42.3'; // Default placeholder

                        // Try to find real value from last scan if input looks like an OID or name
                        if (lastScanData && lastScanData.raw) {
                            const found = lastScanData.raw.find(r => r.oid === oidOrVal || r.name === oidOrVal);
                            if (found) {
                                // Extract numeric part if possible for the preview
                                const numericMatch = String(found.value).match(/^-?\d+(\.\d+)?/);
                                displayVal = numericMatch ? numericMatch[0] : found.value;
                            }
                        }

                        fieldPairs.push(`${key}=${displayVal}`);
                    }
                });

                const fieldsStr = fieldPairs.length > 0 ? ' ' + fieldPairs.join(',') : '';

                // InfluxDB Line Protocol: <measurement>[,<tag_key>=<tag_value>...] <field_key>=<field_value>[,<field_key>=<field_value>...] [timestamp]
                // Colors: Measurement=Blue (#3b82f6), Tags=Red (#ef4444), Fields=Green (#10b981), Timestamp=Yellow (#eab308)

                const measurementHtml = `<span style="color: #3b82f6">${measurement}</span>`;
                const tagsHtml = `<span style="color: #ef4444">${tagsStr}</span>`;
                const fieldsHtml = `<span style="color: #10b981">${fieldsStr}</span>`;
                const timestampHtml = `<span style="color: #eab308"> 1623456789000000000</span>`;

                let fullPreview = `${measurementHtml}${tagsHtml}${fieldsHtml}${timestampHtml}`;

                // Process Table Mappings
                const tableMappingsCards = document.querySelectorAll('.table-mapping-card');
                if (tableMappingsCards.length > 0) {
                    fullPreview += '\n\n# Table Mappings Preview:\n';

                    tableMappingsCards.forEach(card => {
                        const tableOid = card.dataset.tableOid;
                        const tagColumns = [];
                        card.querySelectorAll('.tag-col-checkbox:checked').forEach(cb => tagColumns.push(cb.value));
                        const fieldColumns = [];
                        card.querySelectorAll('.field-col-checkbox:checked').forEach(cb => fieldColumns.push(cb.value));

                        if (tagColumns.length === 0 && fieldColumns.length === 0) return;

                        // Try to get data for this table from last scan
                        let tableData = null;
                        if (lastScanData && lastScanData.tables) {
                            tableData = lastScanData.tables.find(t => t.tableOid === tableOid);
                        }

                        // Show up to 2 sample rows
                        const rowsToShow = tableData ? tableData.rows.slice(0, 2) : [{ index: '1' }, { index: '2' }];

                        rowsToShow.forEach(row => {
                            let rowTagsStr = tagsStr; // Base tags

                            // Add table tags
                            tagColumns.forEach(colId => {
                                const colName = (tableData && tableData.columnNames) ? tableData.columnNames[colId] : `col${colId}`;
                                let val = row[colId] !== undefined ? row[colId] : `val${colId}`;
                                rowTagsStr += `,${colName}=${String(val).replace(/ /g, '\\ ')}`;
                            });

                            let rowFieldsStr = '';

                            // Add table fields
                            const rowFieldPairs = [];
                            fieldColumns.forEach(colId => {
                                const colName = (tableData && tableData.columnNames) ? tableData.columnNames[colId] : `col${colId}`;
                                let val = row[colId] !== undefined ? row[colId] : '42.0';

                                // Clean up value (remove quotes if numeric)
                                let cleanVal = val;
                                // Basic heuristic: if it looks like a number, treat as number. Else quote.
                                // In Line Protocol, strings must be quoted.
                                if (!/^-?\d+(\.\d+)?(i|u)?$/.test(val)) {
                                    // If not strictly numeric, check if it's a known numeric type or force quote
                                    // For preview, let's keep it simple.
                                    // If it contains non-numeric chars (except .), quote it.
                                    if (/[^0-9.-]/.test(val)) {
                                        cleanVal = `"${val}"`;
                                    }
                                }

                                rowFieldPairs.push(`${colName}=${cleanVal}`);
                            });

                            if (rowFieldPairs.length > 0) {
                                rowFieldsStr = ' ' + rowFieldPairs.join(',');
                            } else if (fieldPairs.length > 0) {
                                // If no table fields selected, but we have global fields? 
                                // Usually table rows should have their own fields.
                                // But maybe we want to attach global stats to every row? Rare.
                                rowFieldsStr = fieldsStr;
                            }

                            if (rowTagsStr && rowFieldsStr) {
                                const rTagsHtml = `<span style="color: #ef4444">${rowTagsStr}</span>`;
                                const rFieldsHtml = `<span style="color: #10b981">${rowFieldsStr}</span>`;
                                fullPreview += `${measurementHtml}${rTagsHtml}${rFieldsHtml}${timestampHtml}\n`;
                            }
                        });
                    });
                }

                lpPreview.innerHTML = fullPreview;
            }

            function createTagRow(key = '', value = '') {
                const row = document.createElement('div');
                row.className = 'tag-row';
                row.style.display = 'flex';
                row.style.gap = '0.5rem';
                row.style.alignItems = 'center';
                row.innerHTML = `
                    <input type="text" class="tag-key" placeholder="Key" value="${key}" style="flex: 1; color: #ef4444; font-weight: 500;">
                    <input type="text" class="tag-val" placeholder="Value" value="${value}" style="flex: 2; color: #ef4444; font-weight: 500;">
                    <button class="delete-tag-btn" style="background: #ef4444; padding: 0.5rem; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; border-radius: 6px;">
                        <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                `;

                row.querySelectorAll('input').forEach(input => {
                    input.addEventListener('input', updateLineProtocolPreview);
                    input.addEventListener('focus', () => {
                        // Remove highlight from previous
                        if (activeInputForPicking) {
                            activeInputForPicking.classList.remove('active-input-highlight');
                        }
                        activeInputForPicking = input;
                        activeInputForPicking.classList.add('active-input-highlight');
                    });
                });

                row.querySelector('.delete-tag-btn').addEventListener('click', () => {
                    row.remove();
                    updateLineProtocolPreview();
                });

                tagsContainer.appendChild(row);
            }

            addTagBtn.addEventListener('click', () => {
                createTagRow();
                updateLineProtocolPreview();
            });

            function createFieldRow(key = '', value = '') {
                const row = document.createElement('div');
                row.className = 'field-row';
                row.dataset.key = key;
                row.style.display = 'flex';
                row.style.gap = '0.5rem';
                row.style.alignItems = 'center';
                row.innerHTML = `
                    <input type="text" class="field-key" placeholder="Field Name" value="${key}" style="flex: 1; color: #10b981; font-weight: 500;">
                    <input type="text" class="field-val" placeholder="OID" value="${oid}" style="flex: 1.5; color: #10b981; font-weight: 500;">
                    <input type="text" class="field-scale" placeholder="${translations[currentLang].lp_scale}" value="${scale || ''}" style="flex: 0.5; color: #10b981; font-weight: 500;">
                    <button class="btn-mini" onclick="this.parentElement.remove(); updateLineProtocolPreview();" style="padding: 0.5rem; color: #ef4444; background: none; border: none; cursor: pointer;">&times;</button>
                `;

                row.querySelectorAll('input').forEach(input => {
                    input.addEventListener('input', updateLineProtocolPreview);
                    input.addEventListener('focus', () => {
                        // Remove highlight from previous
                        if (activeInputForPicking) {
                            activeInputForPicking.classList.remove('active-input-highlight');
                        }
                        activeInputForPicking = input;
                        activeInputForPicking.classList.add('active-input-highlight');
                    });
                });

                fieldsContainer.appendChild(row);
            }

            function createTableMappingRow(tableInfo, selectedTags = [], selectedFields = [], selectedFieldScales = {}) {
                const tableOid = tableInfo.tableOid;
                const tableName = tableInfo.tableName || tableOid;

                // Check if already exists
                const existing = document.querySelector(`.table-mapping-card[data-table-oid="${tableOid}"]`);
                if (existing) {
                    existing.scrollIntoView({ behavior: 'smooth' });
                    return;
                }

                const card = document.createElement('div');
                card.className = 'table-mapping-card';
                card.dataset.tableOid = tableOid;
                card.dataset.tableName = tableName;

                let columnsHtml = '';
                tableInfo.columns.forEach(colId => {
                    const name = (tableInfo.columnNames && tableInfo.columnNames[colId]) ? tableInfo.columnNames[colId] : `Col ${colId}`;
                    const isTag = selectedTags.includes(String(colId));
                    const isField = selectedFields.includes(String(colId));
                    const scaleValue = selectedFieldScales[colId] !== undefined ? selectedFieldScales[colId] : '';

                    columnsHtml += `
                        <div class="column-item" style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="flex: 1; font-weight: 500;">${name}</div>
                            <label style="font-size: 0.75rem; color: #ef4444; display: flex; align-items: center; gap: 0.25rem;">
                                <input type="checkbox" class="tag-col-checkbox" value="${colId}" ${isTag ? 'checked' : ''}> Tag
                            </label>
                            <label style="font-size: 0.75rem; color: #10b981; display: flex; align-items: center; gap: 0.25rem;">
                                <input type="checkbox" class="field-col-checkbox" value="${colId}" ${isField ? 'checked' : ''}> Field
                            </label>
                            <input type="text" class="field-scale-col" data-col="${colId}" placeholder="${translations[currentLang].lp_scale}" value="${scaleValue}" style="width: 60px; padding: 2px 4px; font-size: 0.75rem; border: 1px solid var(--border); border-radius: 4px; height: 20px; ${isField ? '' : 'display: none;'}">
                        </div>
                    `;
                });

                card.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                        <div>
                            <div style="font-weight: 600; font-size: 1rem; color: var(--primary);">${tableName}</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">${tableOid}</div>
                        </div>
                        <button class="delete-mapping-btn" style="background: none; border: none; color: #ef4444; cursor: pointer; padding: 4px;">
                            <svg width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                    <div class="mapping-columns-grid">
                        <div>
                            <div style="font-size: 0.8rem; font-weight: 600; color: #ef4444; margin-bottom: 4px;" data-i18n="select_tags">Select Tags (Identifiers)</div>
                            <div class="mapping-column-list">
                                ${columnsHtml}
                            </div>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-muted); padding: 1rem; background: #fff; border: 1px dashed #ddd; border-radius: 4px;">
                            <p><strong data-i18n="standard_practice">Standard Practice:</strong></p>
                            <p data-i18n="std_practice_desc">Use name/descr columns as <b>Tags</b>, and status/numeric columns as <b>Fields</b>.</p>
                        </div>
                    </div>
                `;

                // Add event listeners to checkboxes
                card.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.addEventListener('change', updateLineProtocolPreview);
                });

                card.querySelector('.delete-mapping-btn').addEventListener('click', () => {
                    card.remove();
                    updateLineProtocolPreview();
                });

                tableMappingsContainer.appendChild(card);
            }

            function pickTable(tableOid) {
                if (!lastScanData || !lastScanData.tables) return;
                const tableInfo = lastScanData.tables.find(t => t.tableOid === tableOid);
                if (tableInfo) {
                    createTableMappingRow(tableInfo);
                    switchTab('protocol-tab');

                    // Highlight the table mappings section
                    tableMappingsContainer.scrollIntoView({ behavior: 'smooth' });
                }
            }

            addFieldBtn.addEventListener('click', () => {
                createFieldRow();
                updateLineProtocolPreview();
            });

            lpMeasurement.addEventListener('input', updateLineProtocolPreview);
            lpMeasurement.addEventListener('focus', () => {
                if (activeInputForPicking) {
                    activeInputForPicking.classList.remove('active-input-highlight');
                }
                activeInputForPicking = lpMeasurement;
                activeInputForPicking.classList.add('active-input-highlight');
            });
            updateLineProtocolPreview();

            function pickValue(val) {
                if (activeInputForPicking) {
                    activeInputForPicking.value = val;
                    activeInputForPicking.dispatchEvent(new Event('input'));
                }
            }

            function pickField(name, oid) {
                createFieldRow(name, oid);
                updateLineProtocolPreview();

                // Visual feedback - highlight the tab
                const protocolTabBtn = document.querySelector('button[onclick="switchTab(\'protocol-tab\')"]');
                protocolTabBtn.style.backgroundColor = '#10b981';
                protocolTabBtn.style.color = 'white';
                setTimeout(() => {
                    protocolTabBtn.style.backgroundColor = '';
                    protocolTabBtn.style.color = '';
                }, 1000);
            }

            async function fetchSettings() {
                try {
                    const res = await fetch('/api/settings');
                    const settings = await res.json();
                    if (settings.measurement) {
                        lpMeasurement.value = settings.measurement;
                    }
                    if (settings.tags && Array.isArray(settings.tags)) {
                        tagsContainer.innerHTML = '';
                        settings.tags.forEach(t => createTagRow(t.key, t.value));
                    } else {
                        // Default tags if none found
                        createTagRow('device', 'ups_1');
                        createTagRow('zone', 'ups_room');
                    }
                    if (settings.fields && Array.isArray(settings.fields)) {
                        fieldsContainer.innerHTML = '';
                        settings.fields.forEach(f => createFieldRow(f.key, f.value));
                    } else {
                        // Default fields mapping for demo
                        createFieldRow('temp_c', '1.3.6.1.4.1.999.1.1');
                        createFieldRow('load_pct', '1.3.6.1.4.1.999.1.2');
                    }
                    tableMappingsContainer.innerHTML = '';
                    if (settings.tableMappings && Array.isArray(settings.tableMappings)) {
                        window.savedTableMappings = settings.tableMappings;
                        // If we already have scan data, render them
                        if (lastScanData && lastScanData.tables) {
                            settings.tableMappings.forEach(m => {
                                const info = lastScanData.tables.find(t => t.tableOid === m.tableOid);
                                if (info) createTableMappingRow(info, m.tagColumns, m.fieldColumns);
                            });
                        }
                    }
                    if (settings.agentConfig) {
                        lpAgentConfig.value = settings.agentConfig;
                    }
                    if (settings.outputConfig) {
                        lpOutputConfig.value = settings.outputConfig;
                    }
                    updateLineProtocolPreview();
                } catch (err) {
                    console.error('Failed to fetch settings:', err);
                }
            }

            saveLpSettingsBtn.addEventListener('click', async () => {
                const measurement = lpMeasurement.value.trim();
                const tags = [];
                document.querySelectorAll('.tag-row').forEach(row => {
                    const key = row.querySelector('.tag-key').value.trim();
                    const value = row.querySelector('.tag-val').value.trim();
                    if (key) {
                        tags.push({ key, value });
                    }
                });

                const fields = [];
                document.querySelectorAll('.field-row').forEach(row => {
                    const key = row.querySelector('.field-key').value.trim();
                    const value = row.querySelector('.field-val').value.trim();
                    if (key) {
                        fields.push({ key, value });
                    }
                });

                const tableMappings = [];
                document.querySelectorAll('.table-mapping-card').forEach(card => {
                    const tableOid = card.dataset.tableOid;
                    const tableName = card.dataset.tableName;
                    const tagColumns = [];
                    card.querySelectorAll('.tag-col-checkbox:checked').forEach(cb => tagColumns.push(cb.value));
                    const fieldColumns = [];
                    card.querySelectorAll('.field-col-checkbox:checked').forEach(cb => fieldColumns.push(cb.value));

                    if (tagColumns.length > 0 || fieldColumns.length > 0) {
                        tableMappings.push({ tableOid, tableName, tagColumns, fieldColumns });
                    }
                });

                saveLpSettingsBtn.disabled = true;
                try {
                    const res = await fetch('/api/settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            measurement,
                            tags,
                            fields,
                            tableMappings,
                            agentConfig: lpAgentConfig.value.trim(),
                            outputConfig: lpOutputConfig.value.trim()
                        })
                    });
                    if (res.ok) {
                        const originalText = saveLpSettingsBtn.textContent;
                        saveLpSettingsBtn.textContent = 'Saved!';
                        saveLpSettingsBtn.classList.add('btn-success');

                        // Update preview immediately with current UI state
                        updateLineProtocolPreview();

                        setTimeout(() => {
                            saveLpSettingsBtn.textContent = originalText;
                            saveLpSettingsBtn.classList.remove('btn-success');
                            saveLpSettingsBtn.disabled = false;
                        }, 5000);
                        return;
                    } else {
                        throw new Error('Server returned error');
                    }
                } catch (err) {
                    console.error('Save error:', err);
                    alert('Save error occurred');
                } finally {
                    saveLpSettingsBtn.disabled = false;
                }
            });

            function generateTelegrafToml(config, options = { includeAgent: true, includeOutput: true }) {
                let lines = [];

                if (options.includeAgent && config.agentConfig) {
                    lines.push(config.agentConfig);
                    lines.push('');
                }

                if (options.includeOutput && config.outputConfig) {
                    lines.push(config.outputConfig);
                    lines.push('');
                }

                lines.push('[[inputs.snmp]]');

                // Agents
                const agents = config.agents.map(a => `"${a}"`).join(', ');
                lines.push(`  agents = [ ${agents} ]`);

                // SNMP Version
                let version = 2;
                if (config.snmp_version === '1') version = 1;
                if (config.snmp_version === '3') version = 3;
                lines.push(`  version = ${version}`);

                // Community or V3
                if (version === 3) {
                    if (config.v3) {
                        lines.push(`  sec_name = "${config.v3.user || 'user'}"`);
                        if (config.v3.authProto && config.v3.authProto !== 'none') {
                            lines.push(`  auth_protocol = "${config.v3.authProto}"`);
                            lines.push(`  auth_password = "${config.v3.authPwd}"`);

                            if (config.v3.privProto && config.v3.privProto !== 'none') {
                                lines.push(`  sec_level = "authPriv"`);
                                lines.push(`  priv_protocol = "${config.v3.privProto}"`);
                                lines.push(`  priv_password = "${config.v3.privPwd}"`);
                            } else {
                                lines.push(`  sec_level = "authNoPriv"`);
                            }
                        } else {
                            lines.push(`  sec_level = "noAuthNoPriv"`);
                        }
                    }
                } else {
                    lines.push(`  community = "${config.community || 'public'}"`);
                }

                // Name (measurement)
                if (config.measurement) {
                    lines.push(`  name = "${config.measurement}"`);
                }

                lines.push('');

                // Global Tags
                if (config.tags && config.tags.length > 0) {
                    lines.push('  [inputs.snmp.tags]');
                    config.tags.forEach(t => {
                        lines.push(`    ${t.key} = "${t.value}"`);
                    });
                    lines.push('');
                }

                // Scalar Fields
                if (config.fields && config.fields.length > 0) {
                    config.fields.forEach(f => {
                        lines.push('  [[inputs.snmp.field]]');
                        lines.push(`    name = "${f.key}"`);
                        lines.push(`    oid = "${f.value}"`);
                        if (f.scale && f.scale !== '' && parseFloat(f.scale) !== 1) {
                            lines.push(`    scale = ${f.scale}`);
                        }
                        lines.push('');
                    });
                }

                // Table Mappings
                if (config.tableMappings && config.tableMappings.length > 0) {
                    config.tableMappings.forEach(m => {
                        lines.push('  [[inputs.snmp.table]]');
                        lines.push(`    name = "${m.tableName}"`);
                        lines.push(`    oid = "${m.tableOid}"`);

                        // Find table info from lastScanData to get column names
                        const tableInfo = lastScanData && lastScanData.tables ? lastScanData.tables.find(t => t.tableOid === m.tableOid) : null;

                        // Combine tag and field columns
                        const allCols = [];
                        m.tagColumns.forEach(cId => allCols.push({ id: cId, isTag: true }));
                        m.fieldColumns.forEach(cId => {
                            if (!m.tagColumns.includes(cId)) {
                                allCols.push({ id: cId, isTag: false });
                            }
                        });

                        allCols.forEach(col => {
                            const colName = (tableInfo && tableInfo.columnNames && tableInfo.columnNames[col.id]) ? tableInfo.columnNames[col.id] : `col_${col.id}`;
                            lines.push('    [[inputs.snmp.table.field]]');
                            lines.push(`      name = "${colName}"`);
                            lines.push(`      oid = "${m.tableOid}.${col.id}"`);
                            if (col.isTag) {
                                lines.push(`      is_tag = true`);
                            } else if (m.fieldScales && m.fieldScales[col.id] && m.fieldScales[col.id] !== '' && parseFloat(m.fieldScales[col.id]) !== 1) {
                                lines.push(`      scale = ${m.fieldScales[col.id]}`);
                            }
                            lines.push('');
                        });
                    });
                }

                return lines.join('\n');
            }

            downloadLpTomlBtn.addEventListener('click', () => {
                const measurement = lpMeasurement.value.trim();
                const tags = [];
                document.querySelectorAll('.tag-row').forEach(row => {
                    const key = row.querySelector('.tag-key').value.trim();
                    const value = row.querySelector('.tag-val').value.trim();
                    if (key) {
                        tags.push({ key, value });
                    }
                });

                const fields = [];
                document.querySelectorAll('.field-row').forEach(row => {
                    const key = row.querySelector('.field-key').value.trim();
                    const value = row.querySelector('.field-val').value.trim();
                    if (key) {
                        fields.push({ key, value });
                    }
                });

                const tableMappings = [];
                document.querySelectorAll('.table-mapping-card').forEach(card => {
                    const tableOid = card.dataset.tableOid;
                    const tableName = card.dataset.tableName;
                    const tagColumns = [];
                    card.querySelectorAll('.tag-col-checkbox:checked').forEach(cb => tagColumns.push(cb.value));
                    const fieldColumns = [];
                    card.querySelectorAll('.field-col-checkbox:checked').forEach(cb => fieldColumns.push(cb.value));

                    if (tagColumns.length > 0 || fieldColumns.length > 0) {
                        tableMappings.push({ tableOid, tableName, tagColumns, fieldColumns });
                    }
                });

                const agentsList = targetIp.value.split(/[\n,]/).map(ip => ip.trim()).filter(ip => ip !== '');
                const snmpVersionVal = snmpVersion.value;
                const communityVal = community.value.trim();

                // SNMP v3 params
                const v3Config = snmpVersionVal === '3' ? {
                    user: document.getElementById('v3User').value.trim(),
                    authProto: document.getElementById('v3AuthProto').value,
                    authPwd: document.getElementById('v3AuthPwd').value,
                    privProto: document.getElementById('v3PrivProto').value,
                    privPwd: document.getElementById('v3PrivPwd').value
                } : null;

                const config = {
                    measurement,
                    agents: agentsList,
                    snmp_version: snmpVersionVal,
                    community: communityVal,
                    v3: v3Config,
                    tags,
                    fields,
                    tableMappings,
                    agentConfig: lpAgentConfig.value.trim(),
                    outputConfig: lpOutputConfig.value.trim()
                };

                const tomlString = generateTelegrafToml(config);
                const blob = new Blob([tomlString], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `telegraf_snmp_${measurement || 'config'}.toml`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            fetchSettings();

            // Load available MIBs on start
            fetchMibs();

            mibUploadInput.addEventListener('change', async (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    const formData = new FormData();
                    for (let i = 0; i < files.length; i++) {
                        formData.append('mibFiles', files[i]);
                    }

                    try {
                        const res = await fetch('/api/upload-mib', {
                            method: 'POST',
                            body: formData
                        });

                        let errorMessage = 'Unknown error';
                        const contentType = res.headers.get("content-type");
                        if (contentType && contentType.indexOf("application/json") !== -1) {
                            const data = await res.json();
                            if (res.ok) {
                                fetchMibs(); // Refresh list
                                refreshMibBrowser();
                                return;
                            }
                            errorMessage = data.error || errorMessage;
                        } else {
                            errorMessage = await res.text();
                            // If it's a long HTML page, just show the status
                            if (errorMessage.includes('<!DOCTYPE')) {
                                errorMessage = `Server Error (${res.status}): ${res.statusText}`;
                            }
                        }
                        alert((translations[currentLang].upload_failed || 'Upload failed: ') + errorMessage);
                    } catch (error) {
                        console.error('Upload error:', error);
                        alert((translations[currentLang].upload_failed || 'Upload failed: ') + error.message);
                    }
                    // Reset input
                    e.target.value = '';
                }
            });

            async function fetchMibs() {
                try {
                    const filesRes = await fetch('/api/mibs');
                    const files = filesRes.ok ? await filesRes.json() : [];

                    let activeModules = [];
                    try {
                        const activeRes = await fetch('/api/mibs/active');
                        if (activeRes.ok) activeModules = await activeRes.json();
                    } catch (e) {
                        console.error("Failed to fetch active MIBs", e);
                    }

                    renderMibList(files, activeModules);
                } catch (err) {
                    console.error("Failed to fetch MIBs", err);
                    mibListDiv.innerHTML = `<div style="padding: 0.5rem; color: #ef4444; text-align: center;">Error loading MIB list</div>`;
                }
            }

            function renderMibList(files = [], activeModules = []) {
                if (!Array.isArray(files) || files.length === 0) {
                    mibListDiv.innerHTML = `<div style="padding: 0.5rem; color: var(--text-muted); text-align: center;">${(translations[currentLang] && translations[currentLang].no_mibs) || 'No MIBs found'}</div>`;
                    return;
                }

                // Filter out null/undefined files from active list
                const activeFiles = new Set(activeModules.filter(m => m.file).map(m => m.file));
                const moduleMap = {};
                activeModules.forEach(m => {
                    if (m.file && m.name) moduleMap[m.file] = m.name;
                });

                mibListDiv.innerHTML = '';
                files.forEach(file => {
                    const isActive = activeFiles.has(file);
                    const div = document.createElement('div');
                    div.className = 'mib-item';

                    let actionsHtml = '';
                    const loadText = translations[currentLang].btn_load || 'Load';
                    const unloadText = translations[currentLang].btn_unload || 'Unload';
                    const deleteText = translations[currentLang].btn_delete || 'Delete';

                    if (isActive && moduleMap[file]) {
                        actionsHtml = `<button class="btn-mini" onclick="unloadMib('${moduleMap[file]}')">${unloadText}</button>`;
                    } else {
                        actionsHtml = `<button class="btn-mini btn-success" style="color: white; border: none;" onclick="loadMib('${file}')">${loadText}</button>`;
                    }

                    // Add Delete button to every MIB
                    actionsHtml += `<button class="btn-mini" style="background: #fee2e2; color: #ef4444; border: 1px solid #fca5a5;" onclick="deleteMib('${file}')">${deleteText}</button>`;

                    div.innerHTML = `
                        <div style="flex: 1; min-width: 0; display: flex; align-items: center; gap: 0.5rem;">
                            <span class="status-badge ${isActive ? 'active' : 'inactive'}">${isActive ? (translations[currentLang].status_active || 'Active') : (translations[currentLang].status_file || 'File')}</span>
                            <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.85rem;" title="${file}">${file}</span>
                        </div>
                        <div class="mib-actions">${actionsHtml}</div>
                    `;
                    mibListDiv.appendChild(div);
                });
            }

            async function loadMib(filename) {
                try {
                    const res = await fetch('/api/mibs/load', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filename })
                    });

                    const contentType = res.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        const data = await res.json();
                        if (res.ok && data.success) {
                            fetchMibs();
                            refreshMibBrowser();
                        } else {
                            alert("Load failed: " + (data.error || "Unknown error"));
                        }
                    } else {
                        const text = await res.text();
                        console.error("Server returned non-JSON response:", text);
                        alert(`Load failed: Server returned ${res.status} ${res.statusText}`);
                    }
                } catch (err) {
                    console.error("Failed to load MIB", err);
                    alert("Load failed: " + err.message);
                }
            }

            async function unloadMib(moduleName) {
                try {
                    const res = await fetch('/api/mibs/unload', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ moduleName })
                    });
                    const data = await res.json();
                    if (res.ok && data.success) {
                        fetchMibs();
                        refreshMibBrowser();
                    } else {
                        alert("Unload failed: " + (data.error || "Module might still be required by others"));
                    }
                } catch (err) {
                    console.error("Failed to unload MIB", err);
                    alert("Unload error: " + err.message);
                }
            }

            // Telegraf UI Logic
            async function updateTelegrafStatus() {
                try {
                    const res = await fetch('/api/telegraf/status');
                    const data = await res.json();

                    if (data.running) {
                        telegrafStatusBadge.textContent = translations[currentLang].status_running;
                        telegrafStatusBadge.className = 'status-badge active';
                        startTelegrafBtn.disabled = true;
                        stopTelegrafBtn.disabled = false;
                    } else {
                        telegrafStatusBadge.textContent = translations[currentLang].status_stopped;
                        telegrafStatusBadge.className = 'status-badge inactive';
                        startTelegrafBtn.disabled = false;
                        stopTelegrafBtn.disabled = true;
                    }

                    if (data.logs && data.logs.length > 0) {
                        const logsHtml = data.logs.map(log => {
                            const color = log.type === 'stderr' ? '#f87171' : (log.type === 'info' ? '#60a5fa' : '#f8fafc');
                            return `<div style="color: ${color}">[${new Date(log.time).toLocaleTimeString()}] ${log.msg}</div>`;
                        }).join('');

                        const shouldScroll = telegrafLogsArea.scrollTop + telegrafLogsArea.clientHeight >= telegrafLogsArea.scrollHeight - 20;
                        telegrafLogsArea.innerHTML = logsHtml;
                        if (shouldScroll) {
                            telegrafLogsArea.scrollTop = telegrafLogsArea.scrollHeight;
                        }
                    }
                } catch (err) {
                    console.error("Failed to fetch Telegraf status", err);
                }
            }

            saveTelegrafConfigBtn.addEventListener('click', async () => {
                const configPath = telegrafConfigPath.value.trim();
                if (!configPath) return alert("Please specify path");

                const configContent = generateTelegrafToml(getTelegrafConfigData());

                try {
                    const res = await fetch('/api/telegraf/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: configPath, content: configContent })
                    });

                    const contentType = res.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        const data = await res.json();
                        if (res.ok) {
                            alert(translations[currentLang].telegraf_save_success);
                        } else {
                            alert("Error: " + (data.error || "Unknown error"));
                        }
                    } else {
                        const text = await res.text();
                        alert("Error (Server): " + (text.length > 100 ? text.substring(0, 100) + "..." : text));
                    }
                } catch (err) {
                    alert("Error: " + err.message);
                }
            });

            saveDeviceConfigBtn.addEventListener('click', async () => {
                const configData = getTelegrafConfigData();
                const snTag = configData.tags.find(t => t.key === 'device_sn');

                if (!snTag || !snTag.value) {
                    return alert(translations[currentLang].no_sn_error || "Please add 'device_sn' tag to identify the device file.");
                }

                const fileName = `device_${snTag.value.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.conf`;
                // Explicitly use the telegraf.d directory
                const configPath = `./telegraf.d/${fileName}`;

                // For device configs, we DONT include agent and output (they should be in main telegraf.conf)
                const configContent = generateTelegrafToml(configData, { includeAgent: false, includeOutput: false });

                try {
                    const res = await fetch('/api/telegraf/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: configPath, content: configContent })
                    });

                    if (res.ok) {
                        alert(translations[currentLang].telegraf_save_success);
                    } else {
                        const data = await res.json();
                        alert("Error: " + (data.error || "Unknown error"));
                    }
                } catch (err) {
                    alert("Error: " + err.message);
                }
            });

            function getTelegrafConfigData() {
                const measurement = lpMeasurement.value.trim();
                const tags = [];
                document.querySelectorAll('.tag-row').forEach(row => {
                    const key = row.querySelector('.tag-key').value.trim();
                    const value = row.querySelector('.tag-val').value.trim();
                    if (key) tags.push({ key, value });
                });

                const fields = [];
                document.querySelectorAll('.field-row').forEach(row => {
                    const key = row.querySelector('.field-key').value.trim();
                    const value = row.querySelector('.field-val').value.trim();
                    const scale = row.querySelector('.field-scale').value.trim();
                    if (key) fields.push({ key, value, scale });
                });

                const tableMappings = [];
                document.querySelectorAll('.table-mapping-card').forEach(card => {
                    const tableOid = card.dataset.tableOid;
                    const tableName = card.dataset.tableName;
                    const tagColumns = [];
                    card.querySelectorAll('.tag-col-checkbox:checked').forEach(cb => tagColumns.push(cb.value));

                    const fieldColumns = [];
                    const fieldScales = {};
                    card.querySelectorAll('.field-col-checkbox:checked').forEach(cb => {
                        const colId = cb.value;
                        fieldColumns.push(colId);
                        const scaleInput = card.querySelector(`.field-scale-[data-col="${colId}"]`);
                        if (scaleInput && scaleInput.value.trim()) {
                            fieldScales[colId] = scaleInput.value.trim();
                        }
                    });

                    if (tagColumns.length > 0 || fieldColumns.length > 0) {
                        tableMappings.push({ tableOid, tableName, tagColumns, fieldColumns, fieldScales });
                    }
                });

                const agentsList = targetIp.value.split(/[\n,]/).map(ip => ip.trim()).filter(ip => ip !== '');

                const v3Config = snmpVersion.value === '3' ? {
                    user: document.getElementById('v3User').value.trim(),
                    authProto: document.getElementById('v3AuthProto').value,
                    authPwd: document.getElementById('v3AuthPwd').value,
                    privProto: document.getElementById('v3PrivProto').value,
                    privPwd: document.getElementById('v3PrivPwd').value
                } : null;

                return {
                    measurement,
                    agents: agentsList,
                    snmp_version: snmpVersion.value,
                    community: community.value.trim(),
                    v3: v3Config,
                    tags,
                    fields,
                    tableMappings,
                    agentConfig: lpAgentConfig.value.trim(),
                    outputConfig: lpOutputConfig.value.trim()
                };
            }

            startTelegrafBtn.addEventListener('click', async () => {
                const configPath = telegrafConfigPath.value.trim();
                try {
                    const res = await fetch('/api/telegraf/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: configPath })
                    });

                    const contentType = res.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        const data = await res.json();
                        if (res.ok) {
                            updateTelegrafStatus();
                        } else {
                            alert("Error: " + (data.error || "Unknown error"));
                        }
                    } else {
                        const text = await res.text();
                        alert("Error (Server): " + (text.length > 50 ? text.substring(0, 50) + "..." : text));
                    }
                } catch (err) {
                    alert("Error: " + err.message);
                }
            });

            stopTelegrafBtn.addEventListener('click', async () => {
                try {
                    const res = await fetch('/api/telegraf/stop', { method: 'POST' });
                    if (res.ok) {
                        updateTelegrafStatus();
                    }
                } catch (err) {
                    console.error(err);
                }
            });

            refreshTelegrafStatusBtn.addEventListener('click', updateTelegrafStatus);
            clearTelegrafLogsBtn.addEventListener('click', () => { telegrafLogsArea.innerHTML = ''; });

            // Auto-refresh status every 2 seconds if on telegraf tab OR if process is running
            setInterval(() => {
                if (document.getElementById('telegraf-tab').classList.contains('active')) {
                    updateTelegrafStatus();
                }
            }, 2000);

            function refreshMibBrowser() {
                mibTreeData = null; // Forces re-fetch on next open
                if (mibModal.style.display === 'flex') {
                    openMibBrowser();
                }
            }

            async function deleteMib(filename) {
                if (!confirm(translations[currentLang].confirm_delete_single || 'Are you sure you want to delete this MIB file?')) return;

                try {
                    const res = await fetch('/api/mibs', {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ files: [filename] })
                    });
                    if (res.ok) {
                        fetchMibs();
                        refreshMibBrowser();
                    } else {
                        const err = await res.json();
                        alert((translations[currentLang].delete_failed || 'Delete failed: ') + err.error);
                    }
                } catch (error) {
                    console.error('Delete error:', error);
                    alert(translations[currentLang].delete_failed || 'Delete failed');
                }
            }


            scanBtn.addEventListener('click', async () => {
                const ipList = targetIp.value.split(/[\n,]/).map(ip => ip.trim()).filter(ip => ip !== '');
                const ip = ipList[0]; // Use the first one as template for scanning
                const oid = rootOid.value.trim();
                const comm = community.value.trim();
                const version = snmpVersion.value;

                if (!ip) {
                    showError(translations[currentLang].error_ip);
                    return;
                }

                if (!version) {
                    showError(translations[currentLang].error_version);
                    return;
                }

                setLoading(true);
                showError(null); // Clear errors
                resultsDiv.innerHTML = '';
                toolbarContainer.style.display = 'none';
                snmpStatusBar.style.display = 'none';
                lastScanData = null;

                try {
                    let url = `/api/snmp-walk?target=${encodeURIComponent(ip)}&oid=${encodeURIComponent(oid)}&version=${version}`;

                    if (version === '3') {
                        url += `&v3_user=${encodeURIComponent(document.getElementById('v3User').value)}`;
                        url += `&v3_auth_proto=${encodeURIComponent(document.getElementById('v3AuthProto').value)}`;
                        url += `&v3_auth_pwd=${encodeURIComponent(document.getElementById('v3AuthPwd').value)}`;
                        url += `&v3_priv_proto=${encodeURIComponent(document.getElementById('v3PrivProto').value)}`;
                        url += `&v3_priv_pwd=${encodeURIComponent(document.getElementById('v3PrivPwd').value)}`;
                    } else {
                        url += `&community=${encodeURIComponent(comm)}`;
                    }


                    // Create new AbortController for this request
                    abortController = new AbortController();

                    const response = await fetch(url, { signal: abortController.signal });
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to fetch data');
                    }

                    lastScanData = data;
                    renderTables(data);

                    // Show toolbar (search + download) if ANY results were returned
                    console.log("Checking data for button visibility:", data);
                    // Always show toolbar
                    toolbarContainer.style.display = 'flex';

                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('Scan aborted by user');
                    } else {
                        showError(err.message);
                    }
                } finally {
                    setLoading(false);
                    abortController = null;
                }
            });

            function setLoading(isLoading) {
                if (isLoading) {
                    loadingDiv.style.display = 'block';
                    scanBtn.disabled = true;
                    scanBtn.textContent = translations[currentLang].scanning_btn;
                } else {
                    loadingDiv.style.display = 'none';
                    scanBtn.disabled = false;
                    scanBtn.textContent = translations[currentLang].scan_btn;
                }
            }

            function showError(msg) {
                if (msg) {
                    errorBox.textContent = msg;
                    errorBox.style.display = 'block';
                } else {
                    errorBox.style.display = 'none';
                }
            }

            function renderTables(data) {
                const { tables, raw } = data;
                resultsDiv.innerHTML = '';

                let displayedOids = 0;
                const totalOids = raw ? raw.length : 0;

                // Helper function to check if text matches search query
                const matchesSearch = (text) => {
                    if (!searchQuery) return true;
                    return text && text.toLowerCase().includes(searchQuery);
                };

                // Helper function to check if a table matches search (by name or column names)
                const tableMatchesSearch = (table) => {
                    if (!searchQuery) return true;
                    // Check table name
                    if (matchesSearch(table.oid)) return true;
                    // Check column names
                    if (table.columnNames) {
                        for (const colId of table.columns) {
                            if (matchesSearch(table.columnNames[colId])) return true;
                        }
                    }
                    return false;
                };

                // Get columns that match search query
                const getMatchingColumns = (table) => {
                    if (!searchQuery) return table.columns;
                    // If table name matches, return all columns
                    if (matchesSearch(table.oid)) return table.columns;
                    // Otherwise, filter to columns whose names match
                    return table.columns.filter(col => {
                        const colName = table.columnNames && table.columnNames[col];
                        return matchesSearch(colName);
                    });
                };

                let totalSections = 0;
                let visibleSections = 0;

                // 1. Render General Information (Raw results that are not in any table column)
                // We can identify these by checking which OIDs are in tables and which are not.
                const tableOids = new Set();
                if (tables) {
                    tables.forEach(t => {
                        t.rows.forEach(r => {
                            t.columns.forEach(c => {
                                // This is a bit complex to reconstruct full OID from table structure easily
                                // But usually raw results are things like sysDescr, sysUpTime etc.
                            });
                        });
                    });
                }

                // For now, let's just show all raw results if no tables, or a "Top level fields" section
                // A better way: show raw results that have short OIDs or are known scalars.

                // Actually, let's just render what's available.
                if (raw && raw.length > 0) {
                    let scalarResults = raw.filter(r => {
                        // Heuristic: if it's part of a table, its OID will start with the table's entry OID
                        return !tables.some(t => t.tableOid && r.oid.startsWith(t.tableOid + '.'));
                    });

                    if (document.getElementById('hideNoDesc').checked) {
                        scalarResults = scalarResults.filter(r => r.description);
                    }

                    // Apply search filter to scalar results
                    if (searchQuery) {
                        scalarResults = scalarResults.filter(r =>
                            matchesSearch(r.name) || matchesSearch(r.oid) || matchesSearch(translations[currentLang].general_info)
                        );
                    }

                    totalSections++;
                    if (scalarResults.length > 0) {
                        visibleSections++;
                        displayedOids += scalarResults.length;
                        const card = document.createElement('div');
                        card.className = 'table-card';
                        card.style.marginBottom = '2rem';
                        card.innerHTML = `<div class="card-header"><h2>${translations[currentLang].general_info}</h2></div>`;

                        const tableWrapper = document.createElement('div');
                        tableWrapper.className = 'table-responsive';
                        const tableEl = document.createElement('table');
                        tableEl.innerHTML = `
                        <thead>
                            <tr>
                                <th>${translations[currentLang].name_oid_col}</th>
                                <th>${translations[currentLang].value_col}</th>
                                <th>${translations[currentLang].desc_col}</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${scalarResults.map(r => `
                                <tr>
                                    <td style="font-weight: 500;">
                                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;">
                                            <span>${r.name || r.oid}</span>
                                            <button class="pick-btn" onclick="pickValue('${(r.name || r.oid).replace(/'/g, "\\'")}')" title="Pick Name/OID">Key</button>
                                        </div>
                                    </td>
                                    <td>
                                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;">
                                            <span>${r.value}</span>
                                            <div style="display: flex; gap: 0.25rem;">
                                                <button class="pick-btn" onclick="pickValue('${String(r.value).replace(/'/g, "\\'")}')" title="Pick Value">Val</button>
                                                <button class="pick-field-btn" onclick="pickField('${(r.name || r.oid).replace(/'/g, "\\'")}', '${r.oid.replace(/'/g, "\\'")}')" title="Add to Fields">Field</button>
                                            </div>
                                        </div>
                                    </td>
                                    <td style="color: var(--text-muted); font-size: 0.75rem;">${r.description || translations[currentLang].no_desc_label}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    `;
                        tableWrapper.appendChild(tableEl);
                        card.appendChild(tableWrapper);
                        resultsDiv.appendChild(card);
                    }
                }

                if (!tables || tables.length === 0) {
                    if (!raw || raw.length === 0) {
                        resultsDiv.innerHTML = `<div style="text-align: center; padding: 2rem; color: #64748b;">${translations[currentLang].no_data}</div>`;
                    }
                    // Update search info
                    if (searchQuery) {
                        searchInfo.textContent = translations[currentLang].found_sections.replace('{visible}', visibleSections).replace('{total}', totalSections);
                    } else {
                        searchInfo.textContent = '';
                    }
                    return;
                }

                totalSections += tables.length;

                // Sync with saved mappings if any
                if (window.savedTableMappings) {
                    window.savedTableMappings.forEach(m => {
                        const info = tables.find(t => t.tableOid === m.tableOid);
                        if (info) createTableMappingRow(info, m.tagColumns, m.fieldColumns);
                    });
                }

                tables.forEach(table => {
                    // Skip table if it doesn't match search
                    if (!tableMatchesSearch(table)) return;

                    // Get columns that match search
                    let displayColumns = getMatchingColumns(table);

                    // Filter columns if "hide no description" is checked
                    if (document.getElementById('hideNoDesc').checked) {
                        displayColumns = displayColumns.filter(col => {
                            const desc = table.columnDescriptions && table.columnDescriptions[col] ? table.columnDescriptions[col] : '';
                            return desc && desc.length > 0;
                        });
                    }

                    // If no columns left, skip table
                    if (displayColumns.length === 0) return;

                    visibleSections++;

                    // Count only actual data points in the visible columns
                    displayColumns.forEach(col => {
                        const actualEntriesInColumn = table.rows.filter(r => r[col] !== null).length;
                        displayedOids += actualEntriesInColumn;
                    });

                    const card = document.createElement('div');
                    card.className = 'table-card';

                    const header = document.createElement('div');
                    header.className = 'card-header';
                    header.innerHTML = `
                        <h2>${translations[currentLang].data_group}: ${table.oid}</h2>
                        <button class="pick-field-btn" onclick="pickTable('${table.tableOid}')" style="padding: 0.5rem 1rem;" data-i18n="map_table_btn">${translations[currentLang].map_table_btn}</button>
                    `;
                    card.appendChild(header);

                    const topScrollWrapper = document.createElement('div');
                    topScrollWrapper.className = 'top-scroll-wrapper';
                    const topScrollDummy = document.createElement('div');
                    topScrollDummy.className = 'top-scroll-dummy';
                    topScrollWrapper.appendChild(topScrollDummy);
                    card.appendChild(topScrollWrapper);

                    const tableWrapper = document.createElement('div');
                    tableWrapper.className = 'table-responsive';

                    const tableEl = document.createElement('table');

                    const thead = document.createElement('thead');
                    const headRow = document.createElement('tr');

                    const colHeaders = displayColumns.map(col => {
                        const name = table.columnNames && table.columnNames[col] ? table.columnNames[col] : `Col ${col}`;
                        const desc = table.columnDescriptions && table.columnDescriptions[col] ? table.columnDescriptions[col] : translations[currentLang].no_desc_label;

                        // Limit description length in header for readability
                        const shortDesc = desc.length > 60 ? desc.substring(0, 57) + '...' : desc;

                        return `
                        <th title="${desc.replace(/"/g, '&quot;')}" style="vertical-align: top; min-width: 150px;">
                            <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: 0.5rem; margin-bottom: 0.25rem;">
                                <div style="font-weight: 600;">${name}</div>
                                <button class="pick-btn" onclick="pickValue('${name.replace(/'/g, "\\'")}')" title="Pick Column Name">Key</button>
                            </div>
                            <div style="font-weight: 400; font-size: 0.75rem; color: var(--text-muted); white-space: normal; line-height: 1.2;">
                                ${shortDesc === translations[currentLang].no_desc_label ? `<span style="opacity: 0.5;">${translations[currentLang].no_desc_label}</span>` : shortDesc}
                            </div>
                        </th>`;
                    }).join('');

                    headRow.innerHTML = `<th style="vertical-align: top;">${translations[currentLang].index_col}</th>` + colHeaders;
                    thead.appendChild(headRow);
                    tableEl.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    table.rows.forEach(row => {
                        const tr = document.createElement('tr');
                        let html = `<td>${row.index}</td>`;
                        displayColumns.forEach(col => {
                            const val = row[col] || '-';
                            html += `
                                    <td>
                                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;">
                                            <span>${val}</span>
                                            <div style="display: flex; gap: 0.25rem;">
                                                ${val !== '-' ? `<button class="pick-btn" onclick="pickValue('${String(val).replace(/'/g, "\\'")}')" title="Pick Value">Val</button>` : ''}
                                                <button class="pick-field-btn" onclick="pickField('${(table.columnNames[col] || col).replace(/'/g, "\\'")}', '${table.tableOid}.${col}.${row.index}')" title="Add to Fields">Field</button>
                                            </div>
                                        </div>
                                    </td>`;
                        });
                        tr.innerHTML = html;
                        tbody.appendChild(tr);
                    });
                    tableEl.appendChild(tbody);

                    tableWrapper.appendChild(tableEl);
                    card.appendChild(tableWrapper);
                    resultsDiv.appendChild(card);

                    topScrollWrapper.onscroll = function () {
                        tableWrapper.scrollLeft = topScrollWrapper.scrollLeft;
                    };
                    tableWrapper.onscroll = function () {
                        topScrollWrapper.scrollLeft = tableWrapper.scrollLeft;
                    };

                    const resizeObserver = new ResizeObserver(() => {
                        topScrollDummy.style.width = tableEl.offsetWidth + 'px';
                        if (tableWrapper.offsetWidth >= tableEl.offsetWidth) {
                            topScrollWrapper.style.display = 'none';
                        } else {
                            topScrollWrapper.style.display = 'block';
                        }
                    });
                    resizeObserver.observe(tableEl);
                    resizeObserver.observe(tableWrapper);
                });

                // Update search info
                if (searchQuery) {
                    searchInfo.textContent = translations[currentLang].found_sections.replace('{visible}', visibleSections).replace('{total}', totalSections);
                    if (visibleSections === 0) {
                        resultsDiv.innerHTML = `<div style="text-align: center; padding: 2rem; color: #64748b;">${translations[currentLang].no_results}</div>`;
                    }
                } else {
                    searchInfo.textContent = '';
                }

                // Update OID Statistics
                if (raw && raw.length > 0) {
                    snmpStatusBar.style.display = 'flex';
                    totalOidsCount.textContent = totalOids;
                    displayedOidsCount.textContent = displayedOids;
                } else {
                    snmpStatusBar.style.display = 'none';
                }
            }

            downloadTxtBtn.addEventListener('click', () => {
                if (!lastScanData) return;

                let text = `SNMP SCAN RESULTS\n`;
                text += `Target: ${targetIp.value}\n`;
                text += `Date: ${new Date().toLocaleString()}\n`;
                text += `==========================================\n\n`;

                if (lastScanData.tables && lastScanData.tables.length > 0) {
                    lastScanData.tables.forEach(table => {
                        // Filter columns logic (duplicating for download consistency)
                        let displayColumns = table.columns;
                        if (document.getElementById('hideNoDesc').checked) {
                            displayColumns = displayColumns.filter(col => {
                                const desc = table.columnDescriptions && table.columnDescriptions[col] ? table.columnDescriptions[col] : '';
                                return desc && desc.length > 0;
                            });
                        }
                        if (displayColumns.length === 0) return;

                        text += `DATA GROUP: ${table.oid}\n`;
                        text += `------------------------------------------\n`;

                        const colWidths = { index: 10 };
                        displayColumns.forEach(col => {
                            const name = table.columnNames && table.columnNames[col] ? table.columnNames[col] : `Col ${col}`;
                            colWidths[col] = Math.max(name.length, 15);
                        });

                        let header = `| ${'Index'.padEnd(colWidths.index)} | `;
                        displayColumns.forEach(col => {
                            const name = table.columnNames && table.columnNames[col] ? table.columnNames[col] : `Col ${col}`;
                            header += `${name.padEnd(colWidths[col])} | `;
                        });
                        text += header + `\n`;
                        text += `| ${'-'.repeat(colWidths.index)} | ` + displayColumns.map(col => '-'.repeat(colWidths[col])).join(' | ') + ` | \n`;

                        table.rows.forEach(row => {
                            let rowStr = `| ${String(row.index).padEnd(colWidths.index)} | `;
                            displayColumns.forEach(col => {
                                const val = String(row[col] || '-');
                                rowStr += `${val.padEnd(colWidths[col])} | `;
                            });
                            text += rowStr + `\n`;
                        });
                        text += `\n`;
                    });
                } else if (lastScanData.raw && lastScanData.raw.length > 0) {
                    text += `RAW OID RESULTS\n`;
                    text += `------------------------------------------\n`;

                    let scalarResults = lastScanData.raw;
                    if (document.getElementById('hideNoDesc').checked) {
                        scalarResults = scalarResults.filter(r => r.description);
                    }

                    scalarResults.forEach(item => {
                        const namePart = item.name ? ` (${item.name})` : '';
                        text += `${item.oid}${namePart}: ${item.value}\n`;
                    });
                }

                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `snmp_scan_${targetIp.value.replace(/\./g, '_')}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            downloadCsvBtn.addEventListener('click', () => {
                if (!lastScanData) return;

                let csv = "";
                const escape = (val) => {
                    if (val === null || val === undefined) return '""';
                    let s = String(val).replace(/"/g, '""');
                    return `"${s}"`;
                };

                if (lastScanData.tables && lastScanData.tables.length > 0) {
                    lastScanData.tables.forEach(table => {
                        // Filter columns logic (duplicating for download consistency)
                        let displayColumns = table.columns;
                        if (document.getElementById('hideNoDesc').checked) {
                            displayColumns = displayColumns.filter(col => {
                                const desc = table.columnDescriptions && table.columnDescriptions[col] ? table.columnDescriptions[col] : '';
                                return desc && desc.length > 0;
                            });
                        }
                        if (displayColumns.length === 0) return;

                        csv += escape(`DATA GROUP: ${table.oid}`) + "\n";

                        // Header
                        let headerRow = ["Index"];
                        displayColumns.forEach(col => {
                            const name = table.columnNames && table.columnNames[col] ? table.columnNames[col] : `Col ${col}`;
                            headerRow.push(name);
                        });
                        csv += headerRow.map(escape).join(",") + "\n";

                        // Rows
                        table.rows.forEach(row => {
                            let dataRow = [row.index];
                            displayColumns.forEach(col => {
                                dataRow.push(row[col] || "");
                            });
                            csv += dataRow.map(escape).join(",") + "\n";
                        });
                        csv += "\n"; // Space between tables
                    });
                } else if (lastScanData.raw && lastScanData.raw.length > 0) {
                    let scalarResults = lastScanData.raw;
                    if (document.getElementById('hideNoDesc').checked) {
                        scalarResults = scalarResults.filter(r => r.description);
                    }

                    csv += "OID,Name,Value\n";
                    scalarResults.forEach(item => {
                        csv += `${escape(item.oid)},${escape(item.name || "")},${escape(item.value)}\n`;
                    });
                }

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `snmp_scan_${targetIp.value.replace(/\./g, '_')}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // --- MIB Browser Logic ---
            const mibModal = document.getElementById('mibModal');
            const mibTreeContainer = document.getElementById('mibTreeContainer');
            const mibSearchInput = document.getElementById('mibSearchInput');
            const selectOidBtn = document.getElementById('selectOidBtn');
            let mibTreeData = null;
            let selectedOidInTree = null;

            async function openMibBrowser() {
                mibModal.style.display = 'flex';
                if (!mibTreeData) {
                    try {
                        const response = await fetch('/api/mib-tree');
                        mibTreeData = await response.json();
                        renderMibTree(mibTreeData, mibTreeContainer);
                    } catch (err) {
                        mibTreeContainer.innerHTML = `<div style="color: #ef4444; padding: 1rem;">Failed to load MIB tree: ${err.message}</div>`;
                    }
                }
            }

            function closeMibBrowser() {
                mibModal.style.display = 'none';
            }

            function renderMibTree(node, container, isMatch = true) {
                container.innerHTML = '';
                const element = createTreeNodeElement(node);
                container.appendChild(element);

                // Expand the first few levels by default
                const children = element.querySelector('.mib-tree-children');
                if (children && (node.oid === '1' || node.oid === '1.3' || node.oid === '1.3.6')) {
                    children.classList.add('expanded');
                    element.querySelector('.toggle-icon').classList.add('expanded');
                }
            }

            function createTreeNodeElement(node) {
                const item = document.createElement('div');
                item.className = 'mib-tree-item';

                const hasChildren = node.children && node.children.length > 0;
                const content = document.createElement('div');
                content.className = 'mib-tree-content';
                content.onclick = (e) => {
                    e.stopPropagation();
                    selectMibNode(node, content);
                };

                const toggle = document.createElement('span');
                toggle.className = 'toggle-icon';
                if (hasChildren) {
                    toggle.innerHTML = '<svg width="12" height="12" fill="currentColor" viewBox="0 0 20 20"><path d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"/></svg>';
                    toggle.onclick = (e) => {
                        e.stopPropagation();
                        const childrenDiv = item.querySelector('.mib-tree-children');
                        childrenDiv.classList.toggle('expanded');
                        toggle.classList.toggle('expanded');
                    };
                } else {
                    toggle.style.visibility = 'hidden';
                }

                const icon = document.createElement('span');
                icon.className = 'mib-icon';
                if (hasChildren) {
                    icon.innerHTML = '<svg width="18" height="18" fill="#3b82f6" viewBox="0 0 20 20"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"/></svg>';
                } else {
                    icon.innerHTML = '<svg width="18" height="18" fill="#10b981" viewBox="0 0 24 24"><path d="M17,8C8,10 5.9,16.17 3.82,21.34L5.71,22L6.66,19.7C7.14,19.87 7.64,20 8,20C19,20 22,3 22,3C21,5 14,5.25 9,6.25C4,7.25 2,11.5 2,13.5C2,15.5 3.75,17.25 3.75,17.25C7,8 17,8 17,8Z"/></svg>';
                }

                const name = document.createElement('span');
                name.className = 'mib-tree-name';
                name.textContent = node.name || '(no name)';
                name.title = `${node.name || ''} (${node.oid})\n\n${node.description || ''}`;

                const oid = document.createElement('span');
                oid.className = 'oid-badge';
                oid.textContent = node.oid || '';

                content.appendChild(toggle);
                content.appendChild(icon);
                content.appendChild(name);
                content.appendChild(oid);
                item.appendChild(content);

                if (hasChildren) {
                    const childrenDiv = document.createElement('div');
                    childrenDiv.className = 'mib-tree-children';
                    node.children.forEach(child => {
                        childrenDiv.appendChild(createTreeNodeElement(child));
                    });
                    item.appendChild(childrenDiv);
                }

                return item;
            }

            function selectMibNode(node, element) {
                // Unselect previous
                const prev = document.querySelector('.mib-tree-content.selected');
                if (prev) prev.classList.remove('selected');

                element.classList.add('selected');
                selectedOidInTree = node.oid;
                selectOidBtn.disabled = false;
            }

            selectOidBtn.onclick = () => {
                if (selectedOidInTree) {
                    document.getElementById('rootOid').value = selectedOidInTree;
                    closeMibBrowser();
                }
            };

            // Tree Search
            mibSearchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                if (!mibTreeData) return;

                if (!query) {
                    renderMibTree(mibTreeData, mibTreeContainer);
                    return;
                }

                const filteredTree = filterTree(mibTreeData, query);
                if (filteredTree) {
                    renderMibTree(filteredTree, mibTreeContainer);
                    // Expand all filtered results
                    expandAll(mibTreeContainer);
                } else {
                    mibTreeContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">No matching MIB objects found.</div>';
                }
            });

            function filterTree(node, query) {
                const nameMatch = node.name.toLowerCase().includes(query);
                const oidMatch = node.oid.includes(query);

                let filteredChildren = [];
                if (node.children) {
                    filteredChildren = node.children
                        .map(child => filterTree(child, query))
                        .filter(child => child !== null);
                }

                if (nameMatch || oidMatch || filteredChildren.length > 0) {
                    return {
                        ...node,
                        children: filteredChildren
                    };
                }
                return null;
            }

            function expandAll(container) {
                container.querySelectorAll('.mib-tree-children').forEach(el => el.classList.add('expanded'));
                container.querySelectorAll('.toggle-icon').forEach(el => el.classList.add('expanded'));
            }

            // Close modal when clicking outside
            window.onclick = (event) => {
                if (event.target == mibModal) {
                    closeMibBrowser();
                }
            };
        </script>
    </div>
</body>

</html>